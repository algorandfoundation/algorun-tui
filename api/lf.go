// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	Api_keyScopes = "api_key.Scopes"
)

// Defines values for AccountSigType.
const (
	Lsig AccountSigType = "lsig"
	Msig AccountSigType = "msig"
	Sig  AccountSigType = "sig"
)

// Defines values for AccountInformationParamsFormat.
const (
	AccountInformationParamsFormatJson    AccountInformationParamsFormat = "json"
	AccountInformationParamsFormatMsgpack AccountInformationParamsFormat = "msgpack"
)

// Defines values for AccountInformationParamsExclude.
const (
	All  AccountInformationParamsExclude = "all"
	None AccountInformationParamsExclude = "none"
)

// Defines values for AccountApplicationInformationParamsFormat.
const (
	AccountApplicationInformationParamsFormatJson    AccountApplicationInformationParamsFormat = "json"
	AccountApplicationInformationParamsFormatMsgpack AccountApplicationInformationParamsFormat = "msgpack"
)

// Defines values for AccountAssetInformationParamsFormat.
const (
	AccountAssetInformationParamsFormatJson    AccountAssetInformationParamsFormat = "json"
	AccountAssetInformationParamsFormatMsgpack AccountAssetInformationParamsFormat = "msgpack"
)

// Defines values for GetPendingTransactionsByAddressParamsFormat.
const (
	GetPendingTransactionsByAddressParamsFormatJson    GetPendingTransactionsByAddressParamsFormat = "json"
	GetPendingTransactionsByAddressParamsFormatMsgpack GetPendingTransactionsByAddressParamsFormat = "msgpack"
)

// Defines values for GetBlockParamsFormat.
const (
	GetBlockParamsFormatJson    GetBlockParamsFormat = "json"
	GetBlockParamsFormatMsgpack GetBlockParamsFormat = "msgpack"
)

// Defines values for GetTransactionProofParamsHashtype.
const (
	Sha256    GetTransactionProofParamsHashtype = "sha256"
	Sha512256 GetTransactionProofParamsHashtype = "sha512_256"
)

// Defines values for GetTransactionProofParamsFormat.
const (
	GetTransactionProofParamsFormatJson    GetTransactionProofParamsFormat = "json"
	GetTransactionProofParamsFormatMsgpack GetTransactionProofParamsFormat = "msgpack"
)

// Defines values for GetLedgerStateDeltaForTransactionGroupParamsFormat.
const (
	GetLedgerStateDeltaForTransactionGroupParamsFormatJson    GetLedgerStateDeltaForTransactionGroupParamsFormat = "json"
	GetLedgerStateDeltaForTransactionGroupParamsFormatMsgpack GetLedgerStateDeltaForTransactionGroupParamsFormat = "msgpack"
)

// Defines values for GetLedgerStateDeltaParamsFormat.
const (
	GetLedgerStateDeltaParamsFormatJson    GetLedgerStateDeltaParamsFormat = "json"
	GetLedgerStateDeltaParamsFormatMsgpack GetLedgerStateDeltaParamsFormat = "msgpack"
)

// Defines values for GetTransactionGroupLedgerStateDeltasForRoundParamsFormat.
const (
	GetTransactionGroupLedgerStateDeltasForRoundParamsFormatJson    GetTransactionGroupLedgerStateDeltasForRoundParamsFormat = "json"
	GetTransactionGroupLedgerStateDeltasForRoundParamsFormatMsgpack GetTransactionGroupLedgerStateDeltasForRoundParamsFormat = "msgpack"
)

// Defines values for GetPendingTransactionsParamsFormat.
const (
	GetPendingTransactionsParamsFormatJson    GetPendingTransactionsParamsFormat = "json"
	GetPendingTransactionsParamsFormatMsgpack GetPendingTransactionsParamsFormat = "msgpack"
)

// Defines values for PendingTransactionInformationParamsFormat.
const (
	PendingTransactionInformationParamsFormatJson    PendingTransactionInformationParamsFormat = "json"
	PendingTransactionInformationParamsFormatMsgpack PendingTransactionInformationParamsFormat = "msgpack"
)

// Defines values for SimulateTransactionParamsFormat.
const (
	SimulateTransactionParamsFormatJson    SimulateTransactionParamsFormat = "json"
	SimulateTransactionParamsFormatMsgpack SimulateTransactionParamsFormat = "msgpack"
)

// Account Account information at a given round.
//
// Definition:
// data/basics/userBalance.go : AccountData
type Account struct {
	// Address the account public key
	Address string `json:"address"`

	// Amount \[algo\] total number of MicroAlgos in the account
	Amount int `json:"amount"`

	// AmountWithoutPendingRewards specifies the amount of MicroAlgos in the account, without the pending rewards.
	AmountWithoutPendingRewards int `json:"amount-without-pending-rewards"`

	// AppsLocalState \[appl\] applications local data stored in this account.
	//
	// Note the raw object uses `map[int] -> AppLocalState` for this type.
	AppsLocalState *[]ApplicationLocalState `json:"apps-local-state,omitempty"`

	// AppsTotalExtraPages \[teap\] the sum of all extra application program pages for this account.
	AppsTotalExtraPages *int `json:"apps-total-extra-pages,omitempty"`

	// AppsTotalSchema Specifies maximums on the number of each type that may be stored.
	AppsTotalSchema *ApplicationStateSchema `json:"apps-total-schema,omitempty"`

	// Assets \[asset\] assets held by this account.
	//
	// Note the raw object uses `map[int] -> AssetHolding` for this type.
	Assets *[]AssetHolding `json:"assets,omitempty"`

	// AuthAddr \[spend\] the address against which signing should be checked. If empty, the address of the current account is used. This field can be updated in any transaction by setting the RekeyTo field.
	AuthAddr *string `json:"auth-addr,omitempty"`

	// CreatedApps \[appp\] parameters of applications created by this account including app global data.
	//
	// Note: the raw account uses `map[int] -> AppParams` for this type.
	CreatedApps *[]Application `json:"created-apps,omitempty"`

	// CreatedAssets \[apar\] parameters of assets created by this account.
	//
	// Note: the raw account uses `map[int] -> Asset` for this type.
	CreatedAssets *[]Asset `json:"created-assets,omitempty"`

	// IncentiveEligible Whether or not the account can receive block incentives if its balance is in range at proposal time.
	IncentiveEligible *bool `json:"incentive-eligible,omitempty"`

	// LastHeartbeat The round in which this account last went online, or explicitly renewed their online status.
	LastHeartbeat *int `json:"last-heartbeat,omitempty"`

	// LastProposed The round in which this account last proposed the block.
	LastProposed *int `json:"last-proposed,omitempty"`

	// MinBalance MicroAlgo balance required by the account.
	//
	// The requirement grows based on asset and application usage.
	MinBalance int `json:"min-balance"`

	// Participation AccountParticipation describes the parameters used by this account in consensus protocol.
	Participation *AccountParticipation `json:"participation,omitempty"`

	// PendingRewards amount of MicroAlgos of pending rewards in this account.
	PendingRewards int `json:"pending-rewards"`

	// RewardBase \[ebase\] used as part of the rewards computation. Only applicable to accounts which are participating.
	RewardBase *int `json:"reward-base,omitempty"`

	// Rewards \[ern\] total rewards of MicroAlgos the account has received, including pending rewards.
	Rewards int `json:"rewards"`

	// Round The round for which this information is relevant.
	Round int `json:"round"`

	// SigType Indicates what type of signature is used by this account, must be one of:
	// * sig
	// * msig
	// * lsig
	SigType *AccountSigType `json:"sig-type,omitempty"`

	// Status \[onl\] delegation status of the account's MicroAlgos
	// * Offline - indicates that the associated account is delegated.
	// *  Online  - indicates that the associated account used as part of the delegation pool.
	// *   NotParticipating - indicates that the associated account is neither a delegator nor a delegate.
	Status string `json:"status"`

	// TotalAppsOptedIn The count of all applications that have been opted in, equivalent to the count of application local data (AppLocalState objects) stored in this account.
	TotalAppsOptedIn int `json:"total-apps-opted-in"`

	// TotalAssetsOptedIn The count of all assets that have been opted in, equivalent to the count of AssetHolding objects held by this account.
	TotalAssetsOptedIn int `json:"total-assets-opted-in"`

	// TotalBoxBytes \[tbxb\] The total number of bytes used by this account's app's box keys and values.
	TotalBoxBytes *int `json:"total-box-bytes,omitempty"`

	// TotalBoxes \[tbx\] The number of existing boxes created by this account's app.
	TotalBoxes *int `json:"total-boxes,omitempty"`

	// TotalCreatedApps The count of all apps (AppParams objects) created by this account.
	TotalCreatedApps int `json:"total-created-apps"`

	// TotalCreatedAssets The count of all assets (AssetParams objects) created by this account.
	TotalCreatedAssets int `json:"total-created-assets"`
}

// AccountSigType Indicates what type of signature is used by this account, must be one of:
// * sig
// * msig
// * lsig
type AccountSigType string

// AccountAssetHolding AccountAssetHolding describes the account's asset holding and asset parameters (if either exist) for a specific asset ID.
type AccountAssetHolding struct {
	// AssetHolding Describes an asset held by an account.
	//
	// Definition:
	// data/basics/userBalance.go : AssetHolding
	AssetHolding AssetHolding `json:"asset-holding"`

	// AssetParams AssetParams specifies the parameters for an asset.
	//
	// \[apar\] when part of an AssetConfig transaction.
	//
	// Definition:
	// data/transactions/asset.go : AssetParams
	AssetParams *AssetParams `json:"asset-params,omitempty"`
}

// AccountParticipation AccountParticipation describes the parameters used by this account in consensus protocol.
type AccountParticipation struct {
	// SelectionParticipationKey \[sel\] Selection public key (if any) currently registered for this round.
	SelectionParticipationKey []byte `json:"selection-participation-key"`

	// StateProofKey \[stprf\] Root of the state proof key (if any)
	StateProofKey *[]byte `json:"state-proof-key,omitempty"`

	// VoteFirstValid \[voteFst\] First round for which this participation is valid.
	VoteFirstValid int `json:"vote-first-valid"`

	// VoteKeyDilution \[voteKD\] Number of subkeys in each batch of participation keys.
	VoteKeyDilution int `json:"vote-key-dilution"`

	// VoteLastValid \[voteLst\] Last round for which this participation is valid.
	VoteLastValid int `json:"vote-last-valid"`

	// VoteParticipationKey \[vote\] root participation public key (if any) currently registered for this round.
	VoteParticipationKey []byte `json:"vote-participation-key"`
}

// AccountStateDelta Application state delta.
type AccountStateDelta struct {
	Address string `json:"address"`

	// Delta Application state delta.
	Delta StateDelta `json:"delta"`
}

// AppCallLogs The logged messages from an app call along with the app ID and outer transaction ID. Logs appear in the same order that they were emitted.
type AppCallLogs struct {
	// ApplicationIndex The application from which the logs were generated
	ApplicationIndex int `json:"application-index"`

	// Logs An array of logs
	Logs [][]byte `json:"logs"`

	// TxId The transaction ID of the outer app call that lead to these logs
	TxId string `json:"txId"`
}

// Application Application index and its parameters
type Application struct {
	// Id \[appidx\] application index.
	Id int `json:"id"`

	// Params Stores the global information associated with an application.
	Params ApplicationParams `json:"params"`
}

// ApplicationInitialStates An application's initial global/local/box states that were accessed during simulation.
type ApplicationInitialStates struct {
	// AppBoxes An application's global/local/box state.
	AppBoxes *ApplicationKVStorage `json:"app-boxes,omitempty"`

	// AppGlobals An application's global/local/box state.
	AppGlobals *ApplicationKVStorage `json:"app-globals,omitempty"`

	// AppLocals An application's initial local states tied to different accounts.
	AppLocals *[]ApplicationKVStorage `json:"app-locals,omitempty"`

	// Id Application index.
	Id int `json:"id"`
}

// ApplicationKVStorage An application's global/local/box state.
type ApplicationKVStorage struct {
	// Account The address of the account associated with the local state.
	Account *string `json:"account,omitempty"`

	// Kvs Key-Value pairs representing application states.
	Kvs []AvmKeyValue `json:"kvs"`
}

// ApplicationLocalReference References an account's local state for an application.
type ApplicationLocalReference struct {
	// Account Address of the account with the local state.
	Account string `json:"account"`

	// App Application ID of the local state application.
	App int `json:"app"`
}

// ApplicationLocalState Stores local state associated with an application.
type ApplicationLocalState struct {
	// Id The application which this local state is for.
	Id int `json:"id"`

	// KeyValue Represents a key-value store for use in an application.
	KeyValue *TealKeyValueStore `json:"key-value,omitempty"`

	// Schema Specifies maximums on the number of each type that may be stored.
	Schema ApplicationStateSchema `json:"schema"`
}

// ApplicationParams Stores the global information associated with an application.
type ApplicationParams struct {
	// ApprovalProgram \[approv\] approval program.
	ApprovalProgram []byte `json:"approval-program"`

	// ClearStateProgram \[clearp\] approval program.
	ClearStateProgram []byte `json:"clear-state-program"`

	// Creator The address that created this application. This is the address where the parameters and global state for this application can be found.
	Creator string `json:"creator"`

	// ExtraProgramPages \[epp\] the amount of extra program pages available to this app.
	ExtraProgramPages *int `json:"extra-program-pages,omitempty"`

	// GlobalState Represents a key-value store for use in an application.
	GlobalState *TealKeyValueStore `json:"global-state,omitempty"`

	// GlobalStateSchema Specifies maximums on the number of each type that may be stored.
	GlobalStateSchema *ApplicationStateSchema `json:"global-state-schema,omitempty"`

	// LocalStateSchema Specifies maximums on the number of each type that may be stored.
	LocalStateSchema *ApplicationStateSchema `json:"local-state-schema,omitempty"`
}

// ApplicationStateOperation An operation against an application's global/local/box state.
type ApplicationStateOperation struct {
	// Account For local state changes, the address of the account associated with the local state.
	Account *string `json:"account,omitempty"`

	// AppStateType Type of application state. Value `g` is **global state**, `l` is **local state**, `b` is **boxes**.
	AppStateType string `json:"app-state-type"`

	// Key The key (name) of the global/local/box state.
	Key []byte `json:"key"`

	// NewValue Represents an AVM value.
	NewValue *AvmValue `json:"new-value,omitempty"`

	// Operation Operation type. Value `w` is **write**, `d` is **delete**.
	Operation string `json:"operation"`
}

// ApplicationStateSchema Specifies maximums on the number of each type that may be stored.
type ApplicationStateSchema struct {
	// NumByteSlice \[nbs\] num of byte slices.
	NumByteSlice int `json:"num-byte-slice"`

	// NumUint \[nui\] num of uints.
	NumUint int `json:"num-uint"`
}

// Asset Specifies both the unique identifier and the parameters for an asset
type Asset struct {
	// Index unique asset identifier
	Index int `json:"index"`

	// Params AssetParams specifies the parameters for an asset.
	//
	// \[apar\] when part of an AssetConfig transaction.
	//
	// Definition:
	// data/transactions/asset.go : AssetParams
	Params AssetParams `json:"params"`
}

// AssetHolding Describes an asset held by an account.
//
// Definition:
// data/basics/userBalance.go : AssetHolding
type AssetHolding struct {
	// Amount \[a\] number of units held.
	Amount int `json:"amount"`

	// AssetID Asset ID of the holding.
	AssetID int `json:"asset-id"`

	// IsFrozen \[f\] whether or not the holding is frozen.
	IsFrozen bool `json:"is-frozen"`
}

// AssetHoldingReference References an asset held by an account.
type AssetHoldingReference struct {
	// Account Address of the account holding the asset.
	Account string `json:"account"`

	// Asset Asset ID of the holding.
	Asset int `json:"asset"`
}

// AssetParams AssetParams specifies the parameters for an asset.
//
// \[apar\] when part of an AssetConfig transaction.
//
// Definition:
// data/transactions/asset.go : AssetParams
type AssetParams struct {
	// Clawback \[c\] Address of account used to clawback holdings of this asset.  If empty, clawback is not permitted.
	Clawback *string `json:"clawback,omitempty"`

	// Creator The address that created this asset. This is the address where the parameters for this asset can be found, and also the address where unwanted asset units can be sent in the worst case.
	Creator string `json:"creator"`

	// Decimals \[dc\] The number of digits to use after the decimal point when displaying this asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths. If 2, the base unit of the asset is in hundredths, and so on. This value must be between 0 and 19 (inclusive).
	Decimals int `json:"decimals"`

	// DefaultFrozen \[df\] Whether holdings of this asset are frozen by default.
	DefaultFrozen *bool `json:"default-frozen,omitempty"`

	// Freeze \[f\] Address of account used to freeze holdings of this asset.  If empty, freezing is not permitted.
	Freeze *string `json:"freeze,omitempty"`

	// Manager \[m\] Address of account used to manage the keys of this asset and to destroy it.
	Manager *string `json:"manager,omitempty"`

	// MetadataHash \[am\] A commitment to some unspecified asset metadata. The format of this metadata is up to the application.
	MetadataHash *[]byte `json:"metadata-hash,omitempty"`

	// Name \[an\] Name of this asset, as supplied by the creator. Included only when the asset name is composed of printable utf-8 characters.
	Name *string `json:"name,omitempty"`

	// NameB64 Base64 encoded name of this asset, as supplied by the creator.
	NameB64 *[]byte `json:"name-b64,omitempty"`

	// Reserve \[r\] Address of account holding reserve (non-minted) units of this asset.
	Reserve *string `json:"reserve,omitempty"`

	// Total \[t\] The total number of units of this asset.
	Total int `json:"total"`

	// UnitName \[un\] Name of a unit of this asset, as supplied by the creator. Included only when the name of a unit of this asset is composed of printable utf-8 characters.
	UnitName *string `json:"unit-name,omitempty"`

	// UnitNameB64 Base64 encoded name of a unit of this asset, as supplied by the creator.
	UnitNameB64 *[]byte `json:"unit-name-b64,omitempty"`

	// Url \[au\] URL where more information about the asset can be retrieved. Included only when the URL is composed of printable utf-8 characters.
	Url *string `json:"url,omitempty"`

	// UrlB64 Base64 encoded URL where more information about the asset can be retrieved.
	UrlB64 *[]byte `json:"url-b64,omitempty"`
}

// AvmKeyValue Represents an AVM key-value pair in an application store.
type AvmKeyValue struct {
	Key []byte `json:"key"`

	// Value Represents an AVM value.
	Value AvmValue `json:"value"`
}

// AvmValue Represents an AVM value.
type AvmValue struct {
	// Bytes bytes value.
	Bytes *[]byte `json:"bytes,omitempty"`

	// Type value type. Value `1` refers to **bytes**, value `2` refers to **uint64**
	Type int `json:"type"`

	// Uint uint value.
	Uint *int `json:"uint,omitempty"`
}

// Box Box name and its content.
type Box struct {
	// Name \[name\] box name, base64 encoded
	Name []byte `json:"name"`

	// Round The round for which this information is relevant
	Round int `json:"round"`

	// Value \[value\] box value, base64 encoded.
	Value []byte `json:"value"`
}

// BoxDescriptor Box descriptor describes a Box.
type BoxDescriptor struct {
	// Name Base64 encoded box name
	Name []byte `json:"name"`
}

// BoxReference References a box of an application.
type BoxReference struct {
	// App Application ID which this box belongs to
	App int `json:"app"`

	// Name Base64 encoded box name
	Name []byte `json:"name"`
}

// BuildVersion defines model for BuildVersion.
type BuildVersion struct {
	Branch      string `json:"branch"`
	BuildNumber int64  `json:"build_number"`
	Channel     string `json:"channel"`
	CommitHash  string `json:"commit_hash"`
	Major       int64  `json:"major"`
	Minor       int64  `json:"minor"`
}

// DebugSettingsProf algod mutex and blocking profiling state.
type DebugSettingsProf struct {
	// BlockRate The rate of blocking events. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked. To turn off profiling entirely, pass rate 0.
	BlockRate *int `json:"block-rate,omitempty"`

	// MutexRate The rate of mutex events. On average 1/rate events are reported. To turn off profiling entirely, pass rate 0
	MutexRate *int `json:"mutex-rate,omitempty"`
}

// DryrunRequest Request data type for dryrun endpoint. Given the Transactions and simulated ledger state upload, run TEAL scripts and return debugging information.
type DryrunRequest struct {
	Accounts []Account     `json:"accounts"`
	Apps     []Application `json:"apps"`

	// LatestTimestamp LatestTimestamp is available to some TEAL scripts. Defaults to the latest confirmed timestamp this algod is attached to.
	LatestTimestamp int64 `json:"latest-timestamp"`

	// ProtocolVersion ProtocolVersion specifies a specific version string to operate under, otherwise whatever the current protocol of the network this algod is running in.
	ProtocolVersion string `json:"protocol-version"`

	// Round Round is available to some TEAL scripts. Defaults to the current round on the network this algod is attached to.
	Round   int               `json:"round"`
	Sources []DryrunSource    `json:"sources"`
	Txns    []json.RawMessage `json:"txns"`
}

// DryrunSource DryrunSource is TEAL source text that gets uploaded, compiled, and inserted into transactions or application state.
type DryrunSource struct {
	AppIndex int `json:"app-index"`

	// FieldName FieldName is what kind of sources this is. If lsig then it goes into the transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the Approval Program or Clear State Program of application[this.AppIndex].
	FieldName string `json:"field-name"`
	Source    string `json:"source"`
	TxnIndex  int    `json:"txn-index"`
}

// DryrunState Stores the TEAL eval step data
type DryrunState struct {
	// Error Evaluation error if any
	Error *string `json:"error,omitempty"`

	// Line Line number
	Line int `json:"line"`

	// Pc Program counter
	Pc      int          `json:"pc"`
	Scratch *[]TealValue `json:"scratch,omitempty"`
	Stack   []TealValue  `json:"stack"`
}

// DryrunTxnResult DryrunTxnResult contains any LogicSig or ApplicationCall program debug information and state updates from a dryrun.
type DryrunTxnResult struct {
	AppCallMessages *[]string      `json:"app-call-messages,omitempty"`
	AppCallTrace    *[]DryrunState `json:"app-call-trace,omitempty"`

	// BudgetAdded Budget added during execution of app call transaction.
	BudgetAdded *int `json:"budget-added,omitempty"`

	// BudgetConsumed Budget consumed during execution of app call transaction.
	BudgetConsumed *int `json:"budget-consumed,omitempty"`

	// Disassembly Disassembled program line by line.
	Disassembly []string `json:"disassembly"`

	// GlobalDelta Application state delta.
	GlobalDelta *StateDelta          `json:"global-delta,omitempty"`
	LocalDeltas *[]AccountStateDelta `json:"local-deltas,omitempty"`

	// LogicSigDisassembly Disassembled lsig program line by line.
	LogicSigDisassembly *[]string      `json:"logic-sig-disassembly,omitempty"`
	LogicSigMessages    *[]string      `json:"logic-sig-messages,omitempty"`
	LogicSigTrace       *[]DryrunState `json:"logic-sig-trace,omitempty"`
	Logs                *[][]byte      `json:"logs,omitempty"`
}

// ErrorResponse An error response with optional data field.
type ErrorResponse struct {
	Data    *map[string]interface{} `json:"data,omitempty"`
	Message string                  `json:"message"`
}

// EvalDelta Represents a TEAL value delta.
type EvalDelta struct {
	// Action \[at\] delta action.
	Action int `json:"action"`

	// Bytes \[bs\] bytes value.
	Bytes *string `json:"bytes,omitempty"`

	// Uint \[ui\] uint value.
	Uint *int `json:"uint,omitempty"`
}

// EvalDeltaKeyValue Key-value pairs for StateDelta.
type EvalDeltaKeyValue struct {
	Key string `json:"key"`

	// Value Represents a TEAL value delta.
	Value EvalDelta `json:"value"`
}

// LedgerStateDelta Ledger StateDelta object
type LedgerStateDelta = map[string]interface{}

// LedgerStateDeltaForTransactionGroup Contains a ledger delta for a single transaction group
type LedgerStateDeltaForTransactionGroup struct {
	// Delta Ledger StateDelta object
	Delta LedgerStateDelta `json:"Delta"`
	Ids   []string         `json:"Ids"`
}

// LightBlockHeaderProof Proof of membership and position of a light block header.
type LightBlockHeaderProof struct {
	// Index The index of the light block header in the vector commitment tree
	Index int `json:"index"`

	// Proof The encoded proof.
	Proof []byte `json:"proof"`

	// Treedepth Represents the depth of the tree that is being proven, i.e. the number of edges from a leaf to the root.
	Treedepth int `json:"treedepth"`
}

// ParticipationKey Represents a participation key used by the node.
type ParticipationKey struct {
	// Address Address the key was generated for.
	Address string `json:"address"`

	// EffectiveFirstValid When registered, this is the first round it may be used.
	EffectiveFirstValid *int `json:"effective-first-valid,omitempty"`

	// EffectiveLastValid When registered, this is the last round it may be used.
	EffectiveLastValid *int `json:"effective-last-valid,omitempty"`

	// Id The key's ParticipationID.
	Id string `json:"id"`

	// Key AccountParticipation describes the parameters used by this account in consensus protocol.
	Key AccountParticipation `json:"key"`

	// LastBlockProposal Round when this key was last used to propose a block.
	LastBlockProposal *int `json:"last-block-proposal,omitempty"`

	// LastStateProof Round when this key was last used to generate a state proof.
	LastStateProof *int `json:"last-state-proof,omitempty"`

	// LastVote Round when this key was last used to vote.
	LastVote *int `json:"last-vote,omitempty"`
}

// PendingTransactionResponse Details about a pending transaction. If the transaction was recently confirmed, includes confirmation details like the round and reward details.
type PendingTransactionResponse struct {
	// ApplicationIndex The application index if the transaction was found and it created an application.
	ApplicationIndex *int `json:"application-index,omitempty"`

	// AssetClosingAmount The number of the asset's unit that were transferred to the close-to address.
	AssetClosingAmount *int `json:"asset-closing-amount,omitempty"`

	// AssetIndex The asset index if the transaction was found and it created an asset.
	AssetIndex *int `json:"asset-index,omitempty"`

	// CloseRewards Rewards in microalgos applied to the close remainder to account.
	CloseRewards *int `json:"close-rewards,omitempty"`

	// ClosingAmount Closing amount for the transaction.
	ClosingAmount *int `json:"closing-amount,omitempty"`

	// ConfirmedRound The round where this transaction was confirmed, if present.
	ConfirmedRound *int `json:"confirmed-round,omitempty"`

	// GlobalStateDelta Application state delta.
	GlobalStateDelta *StateDelta `json:"global-state-delta,omitempty"`

	// InnerTxns Inner transactions produced by application execution.
	InnerTxns *[]PendingTransactionResponse `json:"inner-txns,omitempty"`

	// LocalStateDelta Local state key/value changes for the application being executed by this transaction.
	LocalStateDelta *[]AccountStateDelta `json:"local-state-delta,omitempty"`

	// Logs Logs for the application being executed by this transaction.
	Logs *[][]byte `json:"logs,omitempty"`

	// PoolError Indicates that the transaction was kicked out of this node's transaction pool (and specifies why that happened).  An empty string indicates the transaction wasn't kicked out of this node's txpool due to an error.
	PoolError string `json:"pool-error"`

	// ReceiverRewards Rewards in microalgos applied to the receiver account.
	ReceiverRewards *int `json:"receiver-rewards,omitempty"`

	// SenderRewards Rewards in microalgos applied to the sender account.
	SenderRewards *int `json:"sender-rewards,omitempty"`

	// Txn The raw signed transaction.
	Txn map[string]interface{} `json:"txn"`
}

// ScratchChange A write operation into a scratch slot.
type ScratchChange struct {
	// NewValue Represents an AVM value.
	NewValue AvmValue `json:"new-value"`

	// Slot The scratch slot written.
	Slot int `json:"slot"`
}

// SimulateInitialStates Initial states of resources that were accessed during simulation.
type SimulateInitialStates struct {
	// AppInitialStates The initial states of accessed application before simulation. The order of this array is arbitrary.
	AppInitialStates *[]ApplicationInitialStates `json:"app-initial-states,omitempty"`
}

// SimulateRequest Request type for simulation endpoint.
type SimulateRequest struct {
	// AllowEmptySignatures Allows transactions without signatures to be simulated as if they had correct signatures.
	AllowEmptySignatures *bool `json:"allow-empty-signatures,omitempty"`

	// AllowMoreLogging Lifts limits on log opcode usage during simulation.
	AllowMoreLogging *bool `json:"allow-more-logging,omitempty"`

	// AllowUnnamedResources Allows access to unnamed resources during simulation.
	AllowUnnamedResources *bool `json:"allow-unnamed-resources,omitempty"`

	// ExecTraceConfig An object that configures simulation execution trace.
	ExecTraceConfig *SimulateTraceConfig `json:"exec-trace-config,omitempty"`

	// ExtraOpcodeBudget Applies extra opcode budget during simulation for each transaction group.
	ExtraOpcodeBudget *int `json:"extra-opcode-budget,omitempty"`

	// FixSigners If true, signers for transactions that are missing signatures will be fixed during evaluation.
	FixSigners *bool `json:"fix-signers,omitempty"`

	// Round If provided, specifies the round preceding the simulation. State changes through this round will be used to run this simulation. Usually only the 4 most recent rounds will be available (controlled by the node config value MaxAcctLookback). If not specified, defaults to the latest available round.
	Round *int `json:"round,omitempty"`

	// TxnGroups The transaction groups to simulate.
	TxnGroups []SimulateRequestTransactionGroup `json:"txn-groups"`
}

// SimulateRequestTransactionGroup A transaction group to simulate.
type SimulateRequestTransactionGroup struct {
	// Txns An atomic transaction group.
	Txns []json.RawMessage `json:"txns"`
}

// SimulateTraceConfig An object that configures simulation execution trace.
type SimulateTraceConfig struct {
	// Enable A boolean option for opting in execution trace features simulation endpoint.
	Enable *bool `json:"enable,omitempty"`

	// ScratchChange A boolean option enabling returning scratch slot changes together with execution trace during simulation.
	ScratchChange *bool `json:"scratch-change,omitempty"`

	// StackChange A boolean option enabling returning stack changes together with execution trace during simulation.
	StackChange *bool `json:"stack-change,omitempty"`

	// StateChange A boolean option enabling returning application state changes (global, local, and box changes) with the execution trace during simulation.
	StateChange *bool `json:"state-change,omitempty"`
}

// SimulateTransactionGroupResult Simulation result for an atomic transaction group
type SimulateTransactionGroupResult struct {
	// AppBudgetAdded Total budget added during execution of app calls in the transaction group.
	AppBudgetAdded *int `json:"app-budget-added,omitempty"`

	// AppBudgetConsumed Total budget consumed during execution of app calls in the transaction group.
	AppBudgetConsumed *int `json:"app-budget-consumed,omitempty"`

	// FailedAt If present, indicates which transaction in this group caused the failure. This array represents the path to the failing transaction. Indexes are zero based, the first element indicates the top-level transaction, and successive elements indicate deeper inner transactions.
	FailedAt *[]int `json:"failed-at,omitempty"`

	// FailureMessage If present, indicates that the transaction group failed and specifies why that happened
	FailureMessage *string `json:"failure-message,omitempty"`

	// TxnResults Simulation result for individual transactions
	TxnResults []SimulateTransactionResult `json:"txn-results"`

	// UnnamedResourcesAccessed These are resources that were accessed by this group that would normally have caused failure, but were allowed in simulation. Depending on where this object is in the response, the unnamed resources it contains may or may not qualify for group resource sharing. If this is a field in SimulateTransactionGroupResult, the resources do qualify, but if this is a field in SimulateTransactionResult, they do not qualify. In order to make this group valid for actual submission, resources that qualify for group sharing can be made available by any transaction of the group; otherwise, resources must be placed in the same transaction which accessed them.
	UnnamedResourcesAccessed *SimulateUnnamedResourcesAccessed `json:"unnamed-resources-accessed,omitempty"`
}

// SimulateTransactionResult Simulation result for an individual transaction
type SimulateTransactionResult struct {
	// AppBudgetConsumed Budget used during execution of an app call transaction. This value includes budged used by inner app calls spawned by this transaction.
	AppBudgetConsumed *int `json:"app-budget-consumed,omitempty"`

	// ExecTrace The execution trace of calling an app or a logic sig, containing the inner app call trace in a recursive way.
	ExecTrace *SimulationTransactionExecTrace `json:"exec-trace,omitempty"`

	// FixedSigner The account that needed to sign this transaction when no signature was provided and the provided signer was incorrect.
	FixedSigner *string `json:"fixed-signer,omitempty"`

	// LogicSigBudgetConsumed Budget used during execution of a logic sig transaction.
	LogicSigBudgetConsumed *int `json:"logic-sig-budget-consumed,omitempty"`

	// TxnResult Details about a pending transaction. If the transaction was recently confirmed, includes confirmation details like the round and reward details.
	TxnResult PendingTransactionResponse `json:"txn-result"`

	// UnnamedResourcesAccessed These are resources that were accessed by this group that would normally have caused failure, but were allowed in simulation. Depending on where this object is in the response, the unnamed resources it contains may or may not qualify for group resource sharing. If this is a field in SimulateTransactionGroupResult, the resources do qualify, but if this is a field in SimulateTransactionResult, they do not qualify. In order to make this group valid for actual submission, resources that qualify for group sharing can be made available by any transaction of the group; otherwise, resources must be placed in the same transaction which accessed them.
	UnnamedResourcesAccessed *SimulateUnnamedResourcesAccessed `json:"unnamed-resources-accessed,omitempty"`
}

// SimulateUnnamedResourcesAccessed These are resources that were accessed by this group that would normally have caused failure, but were allowed in simulation. Depending on where this object is in the response, the unnamed resources it contains may or may not qualify for group resource sharing. If this is a field in SimulateTransactionGroupResult, the resources do qualify, but if this is a field in SimulateTransactionResult, they do not qualify. In order to make this group valid for actual submission, resources that qualify for group sharing can be made available by any transaction of the group; otherwise, resources must be placed in the same transaction which accessed them.
type SimulateUnnamedResourcesAccessed struct {
	// Accounts The unnamed accounts that were referenced. The order of this array is arbitrary.
	Accounts *[]string `json:"accounts,omitempty"`

	// AppLocals The unnamed application local states that were referenced. The order of this array is arbitrary.
	AppLocals *[]ApplicationLocalReference `json:"app-locals,omitempty"`

	// Apps The unnamed applications that were referenced. The order of this array is arbitrary.
	Apps *[]int `json:"apps,omitempty"`

	// AssetHoldings The unnamed asset holdings that were referenced. The order of this array is arbitrary.
	AssetHoldings *[]AssetHoldingReference `json:"asset-holdings,omitempty"`

	// Assets The unnamed assets that were referenced. The order of this array is arbitrary.
	Assets *[]int `json:"assets,omitempty"`

	// Boxes The unnamed boxes that were referenced. The order of this array is arbitrary.
	Boxes *[]BoxReference `json:"boxes,omitempty"`

	// ExtraBoxRefs The number of extra box references used to increase the IO budget. This is in addition to the references defined in the input transaction group and any referenced to unnamed boxes.
	ExtraBoxRefs *int `json:"extra-box-refs,omitempty"`
}

// SimulationEvalOverrides The set of parameters and limits override during simulation. If this set of parameters is present, then evaluation parameters may differ from standard evaluation in certain ways.
type SimulationEvalOverrides struct {
	// AllowEmptySignatures If true, transactions without signatures are allowed and simulated as if they were properly signed.
	AllowEmptySignatures *bool `json:"allow-empty-signatures,omitempty"`

	// AllowUnnamedResources If true, allows access to unnamed resources during simulation.
	AllowUnnamedResources *bool `json:"allow-unnamed-resources,omitempty"`

	// ExtraOpcodeBudget The extra opcode budget added to each transaction group during simulation
	ExtraOpcodeBudget *int `json:"extra-opcode-budget,omitempty"`

	// FixSigners If true, signers for transactions that are missing signatures will be fixed during evaluation.
	FixSigners *bool `json:"fix-signers,omitempty"`

	// MaxLogCalls The maximum log calls one can make during simulation
	MaxLogCalls *int `json:"max-log-calls,omitempty"`

	// MaxLogSize The maximum byte number to log during simulation
	MaxLogSize *int `json:"max-log-size,omitempty"`
}

// SimulationOpcodeTraceUnit The set of trace information and effect from evaluating a single opcode.
type SimulationOpcodeTraceUnit struct {
	// Pc The program counter of the current opcode being evaluated.
	Pc int `json:"pc"`

	// ScratchChanges The writes into scratch slots.
	ScratchChanges *[]ScratchChange `json:"scratch-changes,omitempty"`

	// SpawnedInners The indexes of the traces for inner transactions spawned by this opcode, if any.
	SpawnedInners *[]int `json:"spawned-inners,omitempty"`

	// StackAdditions The values added by this opcode to the stack.
	StackAdditions *[]AvmValue `json:"stack-additions,omitempty"`

	// StackPopCount The number of deleted stack values by this opcode.
	StackPopCount *int `json:"stack-pop-count,omitempty"`

	// StateChanges The operations against the current application's states.
	StateChanges *[]ApplicationStateOperation `json:"state-changes,omitempty"`
}

// SimulationTransactionExecTrace The execution trace of calling an app or a logic sig, containing the inner app call trace in a recursive way.
type SimulationTransactionExecTrace struct {
	// ApprovalProgramHash SHA512_256 hash digest of the approval program executed in transaction.
	ApprovalProgramHash *[]byte `json:"approval-program-hash,omitempty"`

	// ApprovalProgramTrace Program trace that contains a trace of opcode effects in an approval program.
	ApprovalProgramTrace *[]SimulationOpcodeTraceUnit `json:"approval-program-trace,omitempty"`

	// ClearStateProgramHash SHA512_256 hash digest of the clear state program executed in transaction.
	ClearStateProgramHash *[]byte `json:"clear-state-program-hash,omitempty"`

	// ClearStateProgramTrace Program trace that contains a trace of opcode effects in a clear state program.
	ClearStateProgramTrace *[]SimulationOpcodeTraceUnit `json:"clear-state-program-trace,omitempty"`

	// ClearStateRollback If true, indicates that the clear state program failed and any persistent state changes it produced should be reverted once the program exits.
	ClearStateRollback *bool `json:"clear-state-rollback,omitempty"`

	// ClearStateRollbackError The error message explaining why the clear state program failed. This field will only be populated if clear-state-rollback is true and the failure was due to an execution error.
	ClearStateRollbackError *string `json:"clear-state-rollback-error,omitempty"`

	// InnerTrace An array of SimulationTransactionExecTrace representing the execution trace of any inner transactions executed.
	InnerTrace *[]SimulationTransactionExecTrace `json:"inner-trace,omitempty"`

	// LogicSigHash SHA512_256 hash digest of the logic sig executed in transaction.
	LogicSigHash *[]byte `json:"logic-sig-hash,omitempty"`

	// LogicSigTrace Program trace that contains a trace of opcode effects in a logic sig.
	LogicSigTrace *[]SimulationOpcodeTraceUnit `json:"logic-sig-trace,omitempty"`
}

// StateDelta Application state delta.
type StateDelta = []EvalDeltaKeyValue

// StateProof Represents a state proof and its corresponding message
type StateProof struct {
	// Message Represents the message that the state proofs are attesting to.
	Message StateProofMessage `json:"Message"`

	// StateProof The encoded StateProof for the message.
	StateProof []byte `json:"StateProof"`
}

// StateProofMessage Represents the message that the state proofs are attesting to.
type StateProofMessage struct {
	// BlockHeadersCommitment The vector commitment root on all light block headers within a state proof interval.
	BlockHeadersCommitment []byte `json:"BlockHeadersCommitment"`

	// FirstAttestedRound The first round the message attests to.
	FirstAttestedRound int `json:"FirstAttestedRound"`

	// LastAttestedRound The last round the message attests to.
	LastAttestedRound int `json:"LastAttestedRound"`

	// LnProvenWeight An integer value representing the natural log of the proven weight with 16 bits of precision. This value would be used to verify the next state proof.
	LnProvenWeight int `json:"LnProvenWeight"`

	// VotersCommitment The vector commitment root of the top N accounts to sign the next StateProof.
	VotersCommitment []byte `json:"VotersCommitment"`
}

// TealKeyValue Represents a key-value pair in an application store.
type TealKeyValue struct {
	Key string `json:"key"`

	// Value Represents a TEAL value.
	Value TealValue `json:"value"`
}

// TealKeyValueStore Represents a key-value store for use in an application.
type TealKeyValueStore = []TealKeyValue

// TealValue Represents a TEAL value.
type TealValue struct {
	// Bytes \[tb\] bytes value.
	Bytes string `json:"bytes"`

	// Type \[tt\] value type. Value `1` refers to **bytes**, value `2` refers to **uint**
	Type int `json:"type"`

	// Uint \[ui\] uint value.
	Uint int `json:"uint"`
}

// Version algod version information.
type Version struct {
	Build          BuildVersion `json:"build"`
	GenesisHashB64 []byte       `json:"genesis_hash_b64"`
	GenesisId      string       `json:"genesis_id"`
	Versions       []string     `json:"versions"`
}

// AccountInformationParams defines parameters for AccountInformation.
type AccountInformationParams struct {
	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *AccountInformationParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// Exclude When set to `all` will exclude asset holdings, application local state, created asset parameters, any created application parameters. Defaults to `none`.
	Exclude *AccountInformationParamsExclude `form:"exclude,omitempty" json:"exclude,omitempty"`
}

// AccountInformationParamsFormat defines parameters for AccountInformation.
type AccountInformationParamsFormat string

// AccountInformationParamsExclude defines parameters for AccountInformation.
type AccountInformationParamsExclude string

// AccountApplicationInformationParams defines parameters for AccountApplicationInformation.
type AccountApplicationInformationParams struct {
	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *AccountApplicationInformationParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// AccountApplicationInformationParamsFormat defines parameters for AccountApplicationInformation.
type AccountApplicationInformationParamsFormat string

// AccountAssetsInformationParams defines parameters for AccountAssetsInformation.
type AccountAssetsInformationParams struct {
	// Limit Maximum number of results to return.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Next The next page of results. Use the next token provided by the previous results.
	Next *string `form:"next,omitempty" json:"next,omitempty"`
}

// AccountAssetInformationParams defines parameters for AccountAssetInformation.
type AccountAssetInformationParams struct {
	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *AccountAssetInformationParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// AccountAssetInformationParamsFormat defines parameters for AccountAssetInformation.
type AccountAssetInformationParamsFormat string

// GetPendingTransactionsByAddressParams defines parameters for GetPendingTransactionsByAddress.
type GetPendingTransactionsByAddressParams struct {
	// Max Truncated number of transactions to display. If max=0, returns all pending txns.
	Max *int `form:"max,omitempty" json:"max,omitempty"`

	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *GetPendingTransactionsByAddressParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetPendingTransactionsByAddressParamsFormat defines parameters for GetPendingTransactionsByAddress.
type GetPendingTransactionsByAddressParamsFormat string

// GetApplicationBoxByNameParams defines parameters for GetApplicationBoxByName.
type GetApplicationBoxByNameParams struct {
	// Name A box name, in the goal app call arg form 'encoding:value'. For ints, use the form 'int:1234'. For raw bytes, use the form 'b64:A=='. For printable strings, use the form 'str:hello'. For addresses, use the form 'addr:XYZ...'.
	Name string `form:"name" json:"name"`
}

// GetApplicationBoxesParams defines parameters for GetApplicationBoxes.
type GetApplicationBoxesParams struct {
	// Max Max number of box names to return. If max is not set, or max == 0, returns all box-names.
	Max *int `form:"max,omitempty" json:"max,omitempty"`
}

// GetBlockParams defines parameters for GetBlock.
type GetBlockParams struct {
	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *GetBlockParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetBlockParamsFormat defines parameters for GetBlock.
type GetBlockParamsFormat string

// GetTransactionProofParams defines parameters for GetTransactionProof.
type GetTransactionProofParams struct {
	// Hashtype The type of hash function used to create the proof, must be one of:
	// * sha512_256
	// * sha256
	Hashtype *GetTransactionProofParamsHashtype `form:"hashtype,omitempty" json:"hashtype,omitempty"`

	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *GetTransactionProofParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetTransactionProofParamsHashtype defines parameters for GetTransactionProof.
type GetTransactionProofParamsHashtype string

// GetTransactionProofParamsFormat defines parameters for GetTransactionProof.
type GetTransactionProofParamsFormat string

// StartCatchupParams defines parameters for StartCatchup.
type StartCatchupParams struct {
	// Min Specify the minimum number of blocks which the ledger must be advanced by in order to start the catchup. This is useful for simplifying tools which support fast catchup, they can run the catchup unconditionally and the node will skip the catchup if it is not needed.
	Min *int `form:"min,omitempty" json:"min,omitempty"`
}

// GetLedgerStateDeltaForTransactionGroupParams defines parameters for GetLedgerStateDeltaForTransactionGroup.
type GetLedgerStateDeltaForTransactionGroupParams struct {
	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *GetLedgerStateDeltaForTransactionGroupParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetLedgerStateDeltaForTransactionGroupParamsFormat defines parameters for GetLedgerStateDeltaForTransactionGroup.
type GetLedgerStateDeltaForTransactionGroupParamsFormat string

// GetLedgerStateDeltaParams defines parameters for GetLedgerStateDelta.
type GetLedgerStateDeltaParams struct {
	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *GetLedgerStateDeltaParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetLedgerStateDeltaParamsFormat defines parameters for GetLedgerStateDelta.
type GetLedgerStateDeltaParamsFormat string

// GetTransactionGroupLedgerStateDeltasForRoundParams defines parameters for GetTransactionGroupLedgerStateDeltasForRound.
type GetTransactionGroupLedgerStateDeltasForRoundParams struct {
	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *GetTransactionGroupLedgerStateDeltasForRoundParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetTransactionGroupLedgerStateDeltasForRoundParamsFormat defines parameters for GetTransactionGroupLedgerStateDeltasForRound.
type GetTransactionGroupLedgerStateDeltasForRoundParamsFormat string

// GenerateParticipationKeysParams defines parameters for GenerateParticipationKeys.
type GenerateParticipationKeysParams struct {
	// Dilution Key dilution for two-level participation keys (defaults to sqrt of validity window).
	Dilution *int `form:"dilution,omitempty" json:"dilution,omitempty"`

	// First First round for participation key.
	First int `form:"first" json:"first"`

	// Last Last round for participation key.
	Last int `form:"last" json:"last"`
}

// ShutdownNodeParams defines parameters for ShutdownNode.
type ShutdownNodeParams struct {
	Timeout *int `form:"timeout,omitempty" json:"timeout,omitempty"`
}

// GetPendingTransactionsParams defines parameters for GetPendingTransactions.
type GetPendingTransactionsParams struct {
	// Max Truncated number of transactions to display. If max=0, returns all pending txns.
	Max *int `form:"max,omitempty" json:"max,omitempty"`

	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *GetPendingTransactionsParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetPendingTransactionsParamsFormat defines parameters for GetPendingTransactions.
type GetPendingTransactionsParamsFormat string

// PendingTransactionInformationParams defines parameters for PendingTransactionInformation.
type PendingTransactionInformationParams struct {
	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *PendingTransactionInformationParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// PendingTransactionInformationParamsFormat defines parameters for PendingTransactionInformation.
type PendingTransactionInformationParamsFormat string

// SimulateTransactionParams defines parameters for SimulateTransaction.
type SimulateTransactionParams struct {
	// Format Configures whether the response object is JSON or MessagePack encoded. If not provided, defaults to JSON.
	Format *SimulateTransactionParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// SimulateTransactionParamsFormat defines parameters for SimulateTransaction.
type SimulateTransactionParamsFormat string

// TealDryrunJSONRequestBody defines body for TealDryrun for application/json ContentType.
type TealDryrunJSONRequestBody = DryrunRequest

// SimulateTransactionJSONRequestBody defines body for SimulateTransaction for application/json ContentType.
type SimulateTransactionJSONRequestBody = SimulateRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDebugSettingsProf request
	GetDebugSettingsProf(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutDebugSettingsProf request
	PutDebugSettingsProf(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGenesis request
	GetGenesis(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Metrics request
	Metrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReady request
	GetReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SwaggerJSON request
	SwaggerJSON(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountInformation request
	AccountInformation(ctx context.Context, address string, params *AccountInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountApplicationInformation request
	AccountApplicationInformation(ctx context.Context, address string, applicationId int, params *AccountApplicationInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountAssetsInformation request
	AccountAssetsInformation(ctx context.Context, address string, params *AccountAssetsInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountAssetInformation request
	AccountAssetInformation(ctx context.Context, address string, assetId int, params *AccountAssetInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingTransactionsByAddress request
	GetPendingTransactionsByAddress(ctx context.Context, address string, params *GetPendingTransactionsByAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationByID request
	GetApplicationByID(ctx context.Context, applicationId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationBoxByName request
	GetApplicationBoxByName(ctx context.Context, applicationId int, params *GetApplicationBoxByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplicationBoxes request
	GetApplicationBoxes(ctx context.Context, applicationId int, params *GetApplicationBoxesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetByID request
	GetAssetByID(ctx context.Context, assetId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlock request
	GetBlock(ctx context.Context, round int, params *GetBlockParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockHash request
	GetBlockHash(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLightBlockHeaderProof request
	GetLightBlockHeaderProof(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockLogs request
	GetBlockLogs(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionProof request
	GetTransactionProof(ctx context.Context, round int, txid string, params *GetTransactionProofParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockTxids request
	GetBlockTxids(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AbortCatchup request
	AbortCatchup(ctx context.Context, catchpoint string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartCatchup request
	StartCatchup(ctx context.Context, catchpoint string, params *StartCatchupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLedgerStateDeltaForTransactionGroup request
	GetLedgerStateDeltaForTransactionGroup(ctx context.Context, id string, params *GetLedgerStateDeltaForTransactionGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLedgerStateDelta request
	GetLedgerStateDelta(ctx context.Context, round int, params *GetLedgerStateDeltaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionGroupLedgerStateDeltasForRound request
	GetTransactionGroupLedgerStateDeltasForRound(ctx context.Context, round int, params *GetTransactionGroupLedgerStateDeltasForRoundParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockTimeStampOffset request
	GetBlockTimeStampOffset(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBlockTimeStampOffset request
	SetBlockTimeStampOffset(ctx context.Context, offset int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExperimentalCheck request
	ExperimentalCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSupply request
	GetSupply(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnsetSyncRound request
	UnsetSyncRound(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyncRound request
	GetSyncRound(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSyncRound request
	SetSyncRound(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetParticipationKeys request
	GetParticipationKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddParticipationKeyWithBody request with any body
	AddParticipationKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateParticipationKeys request
	GenerateParticipationKeys(ctx context.Context, address string, params *GenerateParticipationKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteParticipationKeyByID request
	DeleteParticipationKeyByID(ctx context.Context, participationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetParticipationKeyByID request
	GetParticipationKeyByID(ctx context.Context, participationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppendKeysWithBody request with any body
	AppendKeysWithBody(ctx context.Context, participationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShutdownNode request
	ShutdownNode(ctx context.Context, params *ShutdownNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStateProof request
	GetStateProof(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WaitForBlock request
	WaitForBlock(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TealDisassembleWithBody request with any body
	TealDisassembleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TealDryrunWithBody request with any body
	TealDryrunWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TealDryrun(ctx context.Context, body TealDryrunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawTransactionWithBody request with any body
	RawTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RawTransactionAsyncWithBody request with any body
	RawTransactionAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransactionParams request
	TransactionParams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPendingTransactions request
	GetPendingTransactions(ctx context.Context, params *GetPendingTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PendingTransactionInformation request
	PendingTransactionInformation(ctx context.Context, txid string, params *PendingTransactionInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SimulateTransactionWithBody request with any body
	SimulateTransactionWithBody(ctx context.Context, params *SimulateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SimulateTransaction(ctx context.Context, params *SimulateTransactionParams, body SimulateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersion request
	GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDebugSettingsProf(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDebugSettingsProfRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDebugSettingsProf(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDebugSettingsProfRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGenesis(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGenesisRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Metrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SwaggerJSON(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSwaggerJSONRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountInformation(ctx context.Context, address string, params *AccountInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountInformationRequest(c.Server, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountApplicationInformation(ctx context.Context, address string, applicationId int, params *AccountApplicationInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountApplicationInformationRequest(c.Server, address, applicationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountAssetsInformation(ctx context.Context, address string, params *AccountAssetsInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountAssetsInformationRequest(c.Server, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountAssetInformation(ctx context.Context, address string, assetId int, params *AccountAssetInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountAssetInformationRequest(c.Server, address, assetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingTransactionsByAddress(ctx context.Context, address string, params *GetPendingTransactionsByAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingTransactionsByAddressRequest(c.Server, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplicationByID(ctx context.Context, applicationId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationByIDRequest(c.Server, applicationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplicationBoxByName(ctx context.Context, applicationId int, params *GetApplicationBoxByNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationBoxByNameRequest(c.Server, applicationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplicationBoxes(ctx context.Context, applicationId int, params *GetApplicationBoxesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationBoxesRequest(c.Server, applicationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetByID(ctx context.Context, assetId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetByIDRequest(c.Server, assetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlock(ctx context.Context, round int, params *GetBlockParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockRequest(c.Server, round, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockHash(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockHashRequest(c.Server, round)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLightBlockHeaderProof(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLightBlockHeaderProofRequest(c.Server, round)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockLogs(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockLogsRequest(c.Server, round)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionProof(ctx context.Context, round int, txid string, params *GetTransactionProofParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionProofRequest(c.Server, round, txid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockTxids(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockTxidsRequest(c.Server, round)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortCatchup(ctx context.Context, catchpoint string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortCatchupRequest(c.Server, catchpoint)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartCatchup(ctx context.Context, catchpoint string, params *StartCatchupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartCatchupRequest(c.Server, catchpoint, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLedgerStateDeltaForTransactionGroup(ctx context.Context, id string, params *GetLedgerStateDeltaForTransactionGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLedgerStateDeltaForTransactionGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLedgerStateDelta(ctx context.Context, round int, params *GetLedgerStateDeltaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLedgerStateDeltaRequest(c.Server, round, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionGroupLedgerStateDeltasForRound(ctx context.Context, round int, params *GetTransactionGroupLedgerStateDeltasForRoundParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionGroupLedgerStateDeltasForRoundRequest(c.Server, round, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockTimeStampOffset(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockTimeStampOffsetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBlockTimeStampOffset(ctx context.Context, offset int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBlockTimeStampOffsetRequest(c.Server, offset)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExperimentalCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExperimentalCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSupply(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSupplyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnsetSyncRound(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnsetSyncRoundRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyncRound(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyncRoundRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSyncRound(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSyncRoundRequest(c.Server, round)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetParticipationKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetParticipationKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddParticipationKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddParticipationKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateParticipationKeys(ctx context.Context, address string, params *GenerateParticipationKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateParticipationKeysRequest(c.Server, address, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteParticipationKeyByID(ctx context.Context, participationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteParticipationKeyByIDRequest(c.Server, participationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetParticipationKeyByID(ctx context.Context, participationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetParticipationKeyByIDRequest(c.Server, participationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppendKeysWithBody(ctx context.Context, participationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppendKeysRequestWithBody(c.Server, participationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShutdownNode(ctx context.Context, params *ShutdownNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShutdownNodeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStateProof(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStateProofRequest(c.Server, round)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WaitForBlock(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWaitForBlockRequest(c.Server, round)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TealDisassembleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTealDisassembleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TealDryrunWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTealDryrunRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TealDryrun(ctx context.Context, body TealDryrunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTealDryrunRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RawTransactionAsyncWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRawTransactionAsyncRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransactionParams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransactionParamsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPendingTransactions(ctx context.Context, params *GetPendingTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PendingTransactionInformation(ctx context.Context, txid string, params *PendingTransactionInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPendingTransactionInformationRequest(c.Server, txid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SimulateTransactionWithBody(ctx context.Context, params *SimulateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSimulateTransactionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SimulateTransaction(ctx context.Context, params *SimulateTransactionParams, body SimulateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSimulateTransactionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/debug/settings/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDebugSettingsProfRequest generates requests for GetDebugSettingsProf
func NewGetDebugSettingsProfRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/debug/settings/pprof")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutDebugSettingsProfRequest generates requests for PutDebugSettingsProf
func NewPutDebugSettingsProfRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/debug/settings/pprof")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGenesisRequest generates requests for GetGenesis
func NewGetGenesisRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genesis")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetricsRequest generates requests for Metrics
func NewMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReadyRequest generates requests for GetReady
func NewGetReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSwaggerJSONRequest generates requests for SwaggerJSON
func NewSwaggerJSONRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/swagger.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountInformationRequest generates requests for AccountInformation
func NewAccountInformationRequest(server string, address string, params *AccountInformationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Exclude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountApplicationInformationRequest generates requests for AccountApplicationInformation
func NewAccountApplicationInformationRequest(server string, address string, applicationId int, params *AccountApplicationInformationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "application-id", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/accounts/%s/applications/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountAssetsInformationRequest generates requests for AccountAssetsInformation
func NewAccountAssetsInformationRequest(server string, address string, params *AccountAssetsInformationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/accounts/%s/assets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Next != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountAssetInformationRequest generates requests for AccountAssetInformation
func NewAccountAssetInformationRequest(server string, address string, assetId int, params *AccountAssetInformationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/accounts/%s/assets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingTransactionsByAddressRequest generates requests for GetPendingTransactionsByAddress
func NewGetPendingTransactionsByAddressRequest(server string, address string, params *GetPendingTransactionsByAddressParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/accounts/%s/transactions/pending", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Max != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max", runtime.ParamLocationQuery, *params.Max); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationByIDRequest generates requests for GetApplicationByID
func NewGetApplicationByIDRequest(server string, applicationId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "application-id", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/applications/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationBoxByNameRequest generates requests for GetApplicationBoxByName
func NewGetApplicationBoxByNameRequest(server string, applicationId int, params *GetApplicationBoxByNameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "application-id", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/applications/%s/box", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationBoxesRequest generates requests for GetApplicationBoxes
func NewGetApplicationBoxesRequest(server string, applicationId int, params *GetApplicationBoxesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "application-id", runtime.ParamLocationPath, applicationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/applications/%s/boxes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Max != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max", runtime.ParamLocationQuery, *params.Max); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetByIDRequest generates requests for GetAssetByID
func NewGetAssetByIDRequest(server string, assetId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockRequest generates requests for GetBlock
func NewGetBlockRequest(server string, round int, params *GetBlockParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/blocks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockHashRequest generates requests for GetBlockHash
func NewGetBlockHashRequest(server string, round int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/blocks/%s/hash", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLightBlockHeaderProofRequest generates requests for GetLightBlockHeaderProof
func NewGetLightBlockHeaderProofRequest(server string, round int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/blocks/%s/lightheader/proof", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockLogsRequest generates requests for GetBlockLogs
func NewGetBlockLogsRequest(server string, round int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/blocks/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionProofRequest generates requests for GetTransactionProof
func NewGetTransactionProofRequest(server string, round int, txid string, params *GetTransactionProofParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "txid", runtime.ParamLocationPath, txid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/blocks/%s/transactions/%s/proof", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Hashtype != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hashtype", runtime.ParamLocationQuery, *params.Hashtype); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockTxidsRequest generates requests for GetBlockTxids
func NewGetBlockTxidsRequest(server string, round int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/blocks/%s/txids", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAbortCatchupRequest generates requests for AbortCatchup
func NewAbortCatchupRequest(server string, catchpoint string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "catchpoint", runtime.ParamLocationPath, catchpoint)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/catchup/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartCatchupRequest generates requests for StartCatchup
func NewStartCatchupRequest(server string, catchpoint string, params *StartCatchupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "catchpoint", runtime.ParamLocationPath, catchpoint)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/catchup/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Min != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min", runtime.ParamLocationQuery, *params.Min); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLedgerStateDeltaForTransactionGroupRequest generates requests for GetLedgerStateDeltaForTransactionGroup
func NewGetLedgerStateDeltaForTransactionGroupRequest(server string, id string, params *GetLedgerStateDeltaForTransactionGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/deltas/txn/group/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLedgerStateDeltaRequest generates requests for GetLedgerStateDelta
func NewGetLedgerStateDeltaRequest(server string, round int, params *GetLedgerStateDeltaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/deltas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionGroupLedgerStateDeltasForRoundRequest generates requests for GetTransactionGroupLedgerStateDeltasForRound
func NewGetTransactionGroupLedgerStateDeltasForRoundRequest(server string, round int, params *GetTransactionGroupLedgerStateDeltasForRoundParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/deltas/%s/txn/group", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockTimeStampOffsetRequest generates requests for GetBlockTimeStampOffset
func NewGetBlockTimeStampOffsetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/devmode/blocks/offset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBlockTimeStampOffsetRequest generates requests for SetBlockTimeStampOffset
func NewSetBlockTimeStampOffsetRequest(server string, offset int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "offset", runtime.ParamLocationPath, offset)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/devmode/blocks/offset/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExperimentalCheckRequest generates requests for ExperimentalCheck
func NewExperimentalCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/experimental")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSupplyRequest generates requests for GetSupply
func NewGetSupplyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ledger/supply")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnsetSyncRoundRequest generates requests for UnsetSyncRound
func NewUnsetSyncRoundRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ledger/sync")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyncRoundRequest generates requests for GetSyncRound
func NewGetSyncRoundRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ledger/sync")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSyncRoundRequest generates requests for SetSyncRound
func NewSetSyncRoundRequest(server string, round int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ledger/sync/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetParticipationKeysRequest generates requests for GetParticipationKeys
func NewGetParticipationKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/participation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddParticipationKeyRequestWithBody generates requests for AddParticipationKey with any type of body
func NewAddParticipationKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/participation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateParticipationKeysRequest generates requests for GenerateParticipationKeys
func NewGenerateParticipationKeysRequest(server string, address string, params *GenerateParticipationKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/participation/generate/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Dilution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dilution", runtime.ParamLocationQuery, *params.Dilution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, params.First); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last", runtime.ParamLocationQuery, params.Last); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteParticipationKeyByIDRequest generates requests for DeleteParticipationKeyByID
func NewDeleteParticipationKeyByIDRequest(server string, participationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "participation-id", runtime.ParamLocationPath, participationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/participation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetParticipationKeyByIDRequest generates requests for GetParticipationKeyByID
func NewGetParticipationKeyByIDRequest(server string, participationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "participation-id", runtime.ParamLocationPath, participationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/participation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppendKeysRequestWithBody generates requests for AppendKeys with any type of body
func NewAppendKeysRequestWithBody(server string, participationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "participation-id", runtime.ParamLocationPath, participationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/participation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShutdownNodeRequest generates requests for ShutdownNode
func NewShutdownNodeRequest(server string, params *ShutdownNodeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/shutdown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStateProofRequest generates requests for GetStateProof
func NewGetStateProofRequest(server string, round int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stateproofs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWaitForBlockRequest generates requests for WaitForBlock
func NewWaitForBlockRequest(server string, round int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "round", runtime.ParamLocationPath, round)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/status/wait-for-block-after/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTealDisassembleRequestWithBody generates requests for TealDisassemble with any type of body
func NewTealDisassembleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/teal/disassemble")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTealDryrunRequest calls the generic TealDryrun builder with application/json body
func NewTealDryrunRequest(server string, body TealDryrunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTealDryrunRequestWithBody(server, "application/json", bodyReader)
}

// NewTealDryrunRequestWithBody generates requests for TealDryrun with any type of body
func NewTealDryrunRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/teal/dryrun")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRawTransactionRequestWithBody generates requests for RawTransaction with any type of body
func NewRawTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRawTransactionAsyncRequestWithBody generates requests for RawTransactionAsync with any type of body
func NewRawTransactionAsyncRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/transactions/async")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransactionParamsRequest generates requests for TransactionParams
func NewTransactionParamsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/transactions/params")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPendingTransactionsRequest generates requests for GetPendingTransactions
func NewGetPendingTransactionsRequest(server string, params *GetPendingTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/transactions/pending")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Max != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max", runtime.ParamLocationQuery, *params.Max); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPendingTransactionInformationRequest generates requests for PendingTransactionInformation
func NewPendingTransactionInformationRequest(server string, txid string, params *PendingTransactionInformationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "txid", runtime.ParamLocationPath, txid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/transactions/pending/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSimulateTransactionRequest calls the generic SimulateTransaction builder with application/json body
func NewSimulateTransactionRequest(server string, params *SimulateTransactionParams, body SimulateTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSimulateTransactionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSimulateTransactionRequestWithBody generates requests for SimulateTransaction with any type of body
func NewSimulateTransactionRequestWithBody(server string, params *SimulateTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/transactions/simulate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVersionRequest generates requests for GetVersion
func NewGetVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetDebugSettingsProfWithResponse request
	GetDebugSettingsProfWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDebugSettingsProfResponse, error)

	// PutDebugSettingsProfWithResponse request
	PutDebugSettingsProfWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PutDebugSettingsProfResponse, error)

	// GetGenesisWithResponse request
	GetGenesisWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGenesisResponse, error)

	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// MetricsWithResponse request
	MetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetricsResponse, error)

	// GetReadyWithResponse request
	GetReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadyResponse, error)

	// SwaggerJSONWithResponse request
	SwaggerJSONWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SwaggerJSONResponse, error)

	// AccountInformationWithResponse request
	AccountInformationWithResponse(ctx context.Context, address string, params *AccountInformationParams, reqEditors ...RequestEditorFn) (*AccountInformationResponse, error)

	// AccountApplicationInformationWithResponse request
	AccountApplicationInformationWithResponse(ctx context.Context, address string, applicationId int, params *AccountApplicationInformationParams, reqEditors ...RequestEditorFn) (*AccountApplicationInformationResponse, error)

	// AccountAssetsInformationWithResponse request
	AccountAssetsInformationWithResponse(ctx context.Context, address string, params *AccountAssetsInformationParams, reqEditors ...RequestEditorFn) (*AccountAssetsInformationResponse, error)

	// AccountAssetInformationWithResponse request
	AccountAssetInformationWithResponse(ctx context.Context, address string, assetId int, params *AccountAssetInformationParams, reqEditors ...RequestEditorFn) (*AccountAssetInformationResponse, error)

	// GetPendingTransactionsByAddressWithResponse request
	GetPendingTransactionsByAddressWithResponse(ctx context.Context, address string, params *GetPendingTransactionsByAddressParams, reqEditors ...RequestEditorFn) (*GetPendingTransactionsByAddressResponse, error)

	// GetApplicationByIDWithResponse request
	GetApplicationByIDWithResponse(ctx context.Context, applicationId int, reqEditors ...RequestEditorFn) (*GetApplicationByIDResponse, error)

	// GetApplicationBoxByNameWithResponse request
	GetApplicationBoxByNameWithResponse(ctx context.Context, applicationId int, params *GetApplicationBoxByNameParams, reqEditors ...RequestEditorFn) (*GetApplicationBoxByNameResponse, error)

	// GetApplicationBoxesWithResponse request
	GetApplicationBoxesWithResponse(ctx context.Context, applicationId int, params *GetApplicationBoxesParams, reqEditors ...RequestEditorFn) (*GetApplicationBoxesResponse, error)

	// GetAssetByIDWithResponse request
	GetAssetByIDWithResponse(ctx context.Context, assetId int, reqEditors ...RequestEditorFn) (*GetAssetByIDResponse, error)

	// GetBlockWithResponse request
	GetBlockWithResponse(ctx context.Context, round int, params *GetBlockParams, reqEditors ...RequestEditorFn) (*GetBlockResponse, error)

	// GetBlockHashWithResponse request
	GetBlockHashWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*GetBlockHashResponse, error)

	// GetLightBlockHeaderProofWithResponse request
	GetLightBlockHeaderProofWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*GetLightBlockHeaderProofResponse, error)

	// GetBlockLogsWithResponse request
	GetBlockLogsWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*GetBlockLogsResponse, error)

	// GetTransactionProofWithResponse request
	GetTransactionProofWithResponse(ctx context.Context, round int, txid string, params *GetTransactionProofParams, reqEditors ...RequestEditorFn) (*GetTransactionProofResponse, error)

	// GetBlockTxidsWithResponse request
	GetBlockTxidsWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*GetBlockTxidsResponse, error)

	// AbortCatchupWithResponse request
	AbortCatchupWithResponse(ctx context.Context, catchpoint string, reqEditors ...RequestEditorFn) (*AbortCatchupResponse, error)

	// StartCatchupWithResponse request
	StartCatchupWithResponse(ctx context.Context, catchpoint string, params *StartCatchupParams, reqEditors ...RequestEditorFn) (*StartCatchupResponse, error)

	// GetLedgerStateDeltaForTransactionGroupWithResponse request
	GetLedgerStateDeltaForTransactionGroupWithResponse(ctx context.Context, id string, params *GetLedgerStateDeltaForTransactionGroupParams, reqEditors ...RequestEditorFn) (*GetLedgerStateDeltaForTransactionGroupResponse, error)

	// GetLedgerStateDeltaWithResponse request
	GetLedgerStateDeltaWithResponse(ctx context.Context, round int, params *GetLedgerStateDeltaParams, reqEditors ...RequestEditorFn) (*GetLedgerStateDeltaResponse, error)

	// GetTransactionGroupLedgerStateDeltasForRoundWithResponse request
	GetTransactionGroupLedgerStateDeltasForRoundWithResponse(ctx context.Context, round int, params *GetTransactionGroupLedgerStateDeltasForRoundParams, reqEditors ...RequestEditorFn) (*GetTransactionGroupLedgerStateDeltasForRoundResponse, error)

	// GetBlockTimeStampOffsetWithResponse request
	GetBlockTimeStampOffsetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBlockTimeStampOffsetResponse, error)

	// SetBlockTimeStampOffsetWithResponse request
	SetBlockTimeStampOffsetWithResponse(ctx context.Context, offset int, reqEditors ...RequestEditorFn) (*SetBlockTimeStampOffsetResponse, error)

	// ExperimentalCheckWithResponse request
	ExperimentalCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExperimentalCheckResponse, error)

	// GetSupplyWithResponse request
	GetSupplyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSupplyResponse, error)

	// UnsetSyncRoundWithResponse request
	UnsetSyncRoundWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UnsetSyncRoundResponse, error)

	// GetSyncRoundWithResponse request
	GetSyncRoundWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSyncRoundResponse, error)

	// SetSyncRoundWithResponse request
	SetSyncRoundWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*SetSyncRoundResponse, error)

	// GetParticipationKeysWithResponse request
	GetParticipationKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetParticipationKeysResponse, error)

	// AddParticipationKeyWithBodyWithResponse request with any body
	AddParticipationKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddParticipationKeyResponse, error)

	// GenerateParticipationKeysWithResponse request
	GenerateParticipationKeysWithResponse(ctx context.Context, address string, params *GenerateParticipationKeysParams, reqEditors ...RequestEditorFn) (*GenerateParticipationKeysResponse, error)

	// DeleteParticipationKeyByIDWithResponse request
	DeleteParticipationKeyByIDWithResponse(ctx context.Context, participationId string, reqEditors ...RequestEditorFn) (*DeleteParticipationKeyByIDResponse, error)

	// GetParticipationKeyByIDWithResponse request
	GetParticipationKeyByIDWithResponse(ctx context.Context, participationId string, reqEditors ...RequestEditorFn) (*GetParticipationKeyByIDResponse, error)

	// AppendKeysWithBodyWithResponse request with any body
	AppendKeysWithBodyWithResponse(ctx context.Context, participationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppendKeysResponse, error)

	// ShutdownNodeWithResponse request
	ShutdownNodeWithResponse(ctx context.Context, params *ShutdownNodeParams, reqEditors ...RequestEditorFn) (*ShutdownNodeResponse, error)

	// GetStateProofWithResponse request
	GetStateProofWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*GetStateProofResponse, error)

	// GetStatusWithResponse request
	GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)

	// WaitForBlockWithResponse request
	WaitForBlockWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*WaitForBlockResponse, error)

	// TealDisassembleWithBodyWithResponse request with any body
	TealDisassembleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TealDisassembleResponse, error)

	// TealDryrunWithBodyWithResponse request with any body
	TealDryrunWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TealDryrunResponse, error)

	TealDryrunWithResponse(ctx context.Context, body TealDryrunJSONRequestBody, reqEditors ...RequestEditorFn) (*TealDryrunResponse, error)

	// RawTransactionWithBodyWithResponse request with any body
	RawTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RawTransactionResponse, error)

	// RawTransactionAsyncWithBodyWithResponse request with any body
	RawTransactionAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RawTransactionAsyncResponse, error)

	// TransactionParamsWithResponse request
	TransactionParamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransactionParamsResponse, error)

	// GetPendingTransactionsWithResponse request
	GetPendingTransactionsWithResponse(ctx context.Context, params *GetPendingTransactionsParams, reqEditors ...RequestEditorFn) (*GetPendingTransactionsResponse, error)

	// PendingTransactionInformationWithResponse request
	PendingTransactionInformationWithResponse(ctx context.Context, txid string, params *PendingTransactionInformationParams, reqEditors ...RequestEditorFn) (*PendingTransactionInformationResponse, error)

	// SimulateTransactionWithBodyWithResponse request with any body
	SimulateTransactionWithBodyWithResponse(ctx context.Context, params *SimulateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SimulateTransactionResponse, error)

	SimulateTransactionWithResponse(ctx context.Context, params *SimulateTransactionParams, body SimulateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SimulateTransactionResponse, error)

	// GetVersionWithResponse request
	GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error)
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDebugSettingsProfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DebugSettingsProf
}

// Status returns HTTPResponse.Status
func (r GetDebugSettingsProfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDebugSettingsProfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutDebugSettingsProfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DebugSettingsProf
}

// Status returns HTTPResponse.Status
func (r PutDebugSettingsProfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutDebugSettingsProfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGenesisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetGenesisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGenesisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SwaggerJSONResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r SwaggerJSONResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SwaggerJSONResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Account
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AccountInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountApplicationInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AppLocalState Stores local state associated with an application.
		AppLocalState *ApplicationLocalState `json:"app-local-state,omitempty"`

		// CreatedApp Stores the global information associated with an application.
		CreatedApp *ApplicationParams `json:"created-app,omitempty"`

		// Round The round for which this information is relevant.
		Round int `json:"round"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AccountApplicationInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountApplicationInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountAssetsInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AssetHoldings *[]AccountAssetHolding `json:"asset-holdings,omitempty"`

		// NextToken Used for pagination, when making another request provide this token with the next parameter.
		NextToken *string `json:"next-token,omitempty"`

		// Round The round for which this information is relevant.
		Round int `json:"round"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AccountAssetsInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountAssetsInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountAssetInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssetHolding Describes an asset held by an account.
		//
		// Definition:
		// data/basics/userBalance.go : AssetHolding
		AssetHolding *AssetHolding `json:"asset-holding,omitempty"`

		// CreatedAsset AssetParams specifies the parameters for an asset.
		//
		// \[apar\] when part of an AssetConfig transaction.
		//
		// Definition:
		// data/transactions/asset.go : AssetParams
		CreatedAsset *AssetParams `json:"created-asset,omitempty"`

		// Round The round for which this information is relevant.
		Round int `json:"round"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AccountAssetInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountAssetInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingTransactionsByAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TopTransactions An array of signed transaction objects.
		TopTransactions []map[string]interface{} `json:"top-transactions"`

		// TotalTransactions Total number of transactions in the pool.
		TotalTransactions int `json:"total-transactions"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
	JSON503 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPendingTransactionsByAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingTransactionsByAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Application
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetApplicationByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationBoxByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Box
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetApplicationBoxByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationBoxByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationBoxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Boxes []BoxDescriptor `json:"boxes"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetApplicationBoxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationBoxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Asset
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAssetByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Block Block header data.
		Block map[string]interface{} `json:"block"`

		// Cert Optional certificate object. This is only included when the format is set to message pack.
		Cert *map[string]interface{} `json:"cert,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON404 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BlockHash Block header hash.
		BlockHash string `json:"blockHash"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON404 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLightBlockHeaderProofResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LightBlockHeaderProof
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON408      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLightBlockHeaderProofResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLightBlockHeaderProofResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Logs []AppCallLogs `json:"logs"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON404 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionProofResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Hashtype The type of hash function used to create the proof, must be one of:
		// * sha512_256
		// * sha256
		Hashtype GetTransactionProof200Hashtype `json:"hashtype"`

		// Idx Index of the transaction in the block's payset.
		Idx int `json:"idx"`

		// Proof Proof of transaction membership.
		Proof []byte `json:"proof"`

		// Stibhash Hash of SignedTxnInBlock for verifying proof.
		Stibhash []byte `json:"stibhash"`

		// Treedepth Represents the depth of the tree that is being proven, i.e. the number of edges from a leaf to the root.
		Treedepth int `json:"treedepth"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON404 *ErrorResponse
	JSON500 *ErrorResponse
}
type GetTransactionProof200Hashtype string

// Status returns HTTPResponse.Status
func (r GetTransactionProofResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionProofResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockTxidsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BlockTxids Block transaction IDs.
		BlockTxids []string `json:"blockTxids"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON404 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockTxidsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockTxidsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AbortCatchupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CatchupMessage Catchup abort response string
		CatchupMessage string `json:"catchup-message"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AbortCatchupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AbortCatchupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartCatchupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CatchupMessage Catchup start response string
		CatchupMessage string `json:"catchup-message"`
	}
	JSON201 *struct {
		// CatchupMessage Catchup start response string
		CatchupMessage string `json:"catchup-message"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON408 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r StartCatchupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartCatchupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLedgerStateDeltaForTransactionGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LedgerStateDelta
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON408      *ErrorResponse
	JSON500      *ErrorResponse
	JSON501      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLedgerStateDeltaForTransactionGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLedgerStateDeltaForTransactionGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLedgerStateDeltaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LedgerStateDelta
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON408      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLedgerStateDeltaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLedgerStateDeltaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionGroupLedgerStateDeltasForRoundResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Deltas []LedgerStateDeltaForTransactionGroup `json:"Deltas"`
	}
	JSON401 *ErrorResponse
	JSON404 *ErrorResponse
	JSON408 *ErrorResponse
	JSON500 *ErrorResponse
	JSON501 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionGroupLedgerStateDeltasForRoundResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionGroupLedgerStateDeltasForRoundResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockTimeStampOffsetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Offset Timestamp offset in seconds.
		Offset int `json:"offset"`
	}
	JSON400 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockTimeStampOffsetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockTimeStampOffsetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBlockTimeStampOffsetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetBlockTimeStampOffsetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBlockTimeStampOffsetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExperimentalCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExperimentalCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExperimentalCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupplyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CurrentRound Round
		CurrentRound int `json:"current_round"`

		// OnlineMoney OnlineMoney
		OnlineMoney int `json:"online-money"`

		// TotalMoney TotalMoney
		TotalMoney int `json:"total-money"`
	}
	JSON401 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSupplyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupplyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnsetSyncRoundResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UnsetSyncRoundResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnsetSyncRoundResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyncRoundResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Round The minimum sync round for the ledger.
		Round int `json:"round"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
	JSON503 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSyncRoundResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyncRoundResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSyncRoundResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetSyncRoundResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSyncRoundResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetParticipationKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ParticipationKey
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetParticipationKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetParticipationKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddParticipationKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// PartId encoding of the participation ID.
		PartId string `json:"partId"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON404 *ErrorResponse
	JSON500 *ErrorResponse
	JSON503 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddParticipationKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddParticipationKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateParticipationKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GenerateParticipationKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateParticipationKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteParticipationKeyByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteParticipationKeyByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteParticipationKeyByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetParticipationKeyByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ParticipationKey
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetParticipationKeyByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetParticipationKeyByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppendKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ParticipationKey
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppendKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppendKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShutdownNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ShutdownNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShutdownNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStateProofResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StateProof
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON408      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetStateProofResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStateProofResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Catchpoint The current catchpoint that is being caught up to
		Catchpoint *string `json:"catchpoint,omitempty"`

		// CatchpointAcquiredBlocks The number of blocks that have already been obtained by the node as part of the catchup
		CatchpointAcquiredBlocks *int `json:"catchpoint-acquired-blocks,omitempty"`

		// CatchpointProcessedAccounts The number of accounts from the current catchpoint that have been processed so far as part of the catchup
		CatchpointProcessedAccounts *int `json:"catchpoint-processed-accounts,omitempty"`

		// CatchpointProcessedKvs The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup
		CatchpointProcessedKvs *int `json:"catchpoint-processed-kvs,omitempty"`

		// CatchpointTotalAccounts The total number of accounts included in the current catchpoint
		CatchpointTotalAccounts *int `json:"catchpoint-total-accounts,omitempty"`

		// CatchpointTotalBlocks The total number of blocks that are required to complete the current catchpoint catchup
		CatchpointTotalBlocks *int `json:"catchpoint-total-blocks,omitempty"`

		// CatchpointTotalKvs The total number of key-values (KVs) included in the current catchpoint
		CatchpointTotalKvs *int `json:"catchpoint-total-kvs,omitempty"`

		// CatchpointVerifiedAccounts The number of accounts from the current catchpoint that have been verified so far as part of the catchup
		CatchpointVerifiedAccounts *int `json:"catchpoint-verified-accounts,omitempty"`

		// CatchpointVerifiedKvs The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup
		CatchpointVerifiedKvs *int `json:"catchpoint-verified-kvs,omitempty"`

		// CatchupTime CatchupTime in nanoseconds
		CatchupTime int `json:"catchup-time"`

		// LastCatchpoint The last catchpoint seen by the node
		LastCatchpoint *string `json:"last-catchpoint,omitempty"`

		// LastRound LastRound indicates the last round seen
		LastRound int `json:"last-round"`

		// LastVersion LastVersion indicates the last consensus version supported
		LastVersion string `json:"last-version"`

		// NextVersion NextVersion of consensus protocol to use
		NextVersion string `json:"next-version"`

		// NextVersionRound NextVersionRound is the round at which the next consensus version will apply
		NextVersionRound int `json:"next-version-round"`

		// NextVersionSupported NextVersionSupported indicates whether the next consensus version is supported by this node
		NextVersionSupported bool `json:"next-version-supported"`

		// StoppedAtUnsupportedRound StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress
		StoppedAtUnsupportedRound bool `json:"stopped-at-unsupported-round"`

		// TimeSinceLastRound TimeSinceLastRound in nanoseconds
		TimeSinceLastRound int `json:"time-since-last-round"`

		// UpgradeDelay Upgrade delay
		UpgradeDelay *int `json:"upgrade-delay,omitempty"`

		// UpgradeNextProtocolVoteBefore Next protocol round
		UpgradeNextProtocolVoteBefore *int `json:"upgrade-next-protocol-vote-before,omitempty"`

		// UpgradeNoVotes No votes cast for consensus upgrade
		UpgradeNoVotes *int `json:"upgrade-no-votes,omitempty"`

		// UpgradeNodeVote This node's upgrade vote
		UpgradeNodeVote *bool `json:"upgrade-node-vote,omitempty"`

		// UpgradeVoteRounds Total voting rounds for current upgrade
		UpgradeVoteRounds *int `json:"upgrade-vote-rounds,omitempty"`

		// UpgradeVotes Total votes cast for consensus upgrade
		UpgradeVotes *int `json:"upgrade-votes,omitempty"`

		// UpgradeVotesRequired Yes votes required for consensus upgrade
		UpgradeVotesRequired *int `json:"upgrade-votes-required,omitempty"`

		// UpgradeYesVotes Yes votes cast for consensus upgrade
		UpgradeYesVotes *int `json:"upgrade-yes-votes,omitempty"`
	}
	JSON401 *ErrorResponse
	JSON500 *string
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WaitForBlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Catchpoint The current catchpoint that is being caught up to
		Catchpoint *string `json:"catchpoint,omitempty"`

		// CatchpointAcquiredBlocks The number of blocks that have already been obtained by the node as part of the catchup
		CatchpointAcquiredBlocks *int `json:"catchpoint-acquired-blocks,omitempty"`

		// CatchpointProcessedAccounts The number of accounts from the current catchpoint that have been processed so far as part of the catchup
		CatchpointProcessedAccounts *int `json:"catchpoint-processed-accounts,omitempty"`

		// CatchpointProcessedKvs The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup
		CatchpointProcessedKvs *int `json:"catchpoint-processed-kvs,omitempty"`

		// CatchpointTotalAccounts The total number of accounts included in the current catchpoint
		CatchpointTotalAccounts *int `json:"catchpoint-total-accounts,omitempty"`

		// CatchpointTotalBlocks The total number of blocks that are required to complete the current catchpoint catchup
		CatchpointTotalBlocks *int `json:"catchpoint-total-blocks,omitempty"`

		// CatchpointTotalKvs The total number of key-values (KVs) included in the current catchpoint
		CatchpointTotalKvs *int `json:"catchpoint-total-kvs,omitempty"`

		// CatchpointVerifiedAccounts The number of accounts from the current catchpoint that have been verified so far as part of the catchup
		CatchpointVerifiedAccounts *int `json:"catchpoint-verified-accounts,omitempty"`

		// CatchpointVerifiedKvs The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup
		CatchpointVerifiedKvs *int `json:"catchpoint-verified-kvs,omitempty"`

		// CatchupTime CatchupTime in nanoseconds
		CatchupTime int `json:"catchup-time"`

		// LastCatchpoint The last catchpoint seen by the node
		LastCatchpoint *string `json:"last-catchpoint,omitempty"`

		// LastRound LastRound indicates the last round seen
		LastRound int `json:"last-round"`

		// LastVersion LastVersion indicates the last consensus version supported
		LastVersion string `json:"last-version"`

		// NextVersion NextVersion of consensus protocol to use
		NextVersion string `json:"next-version"`

		// NextVersionRound NextVersionRound is the round at which the next consensus version will apply
		NextVersionRound int `json:"next-version-round"`

		// NextVersionSupported NextVersionSupported indicates whether the next consensus version is supported by this node
		NextVersionSupported bool `json:"next-version-supported"`

		// StoppedAtUnsupportedRound StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress
		StoppedAtUnsupportedRound bool `json:"stopped-at-unsupported-round"`

		// TimeSinceLastRound TimeSinceLastRound in nanoseconds
		TimeSinceLastRound int `json:"time-since-last-round"`

		// UpgradeDelay Upgrade delay
		UpgradeDelay *int `json:"upgrade-delay,omitempty"`

		// UpgradeNextProtocolVoteBefore Next protocol round
		UpgradeNextProtocolVoteBefore *int `json:"upgrade-next-protocol-vote-before,omitempty"`

		// UpgradeNoVotes No votes cast for consensus upgrade
		UpgradeNoVotes *int `json:"upgrade-no-votes,omitempty"`

		// UpgradeNodeVote This node's upgrade vote
		UpgradeNodeVote *bool `json:"upgrade-node-vote,omitempty"`

		// UpgradeVoteRounds Total voting rounds for current upgrade
		UpgradeVoteRounds *int `json:"upgrade-vote-rounds,omitempty"`

		// UpgradeVotes Total votes cast for consensus upgrade
		UpgradeVotes *int `json:"upgrade-votes,omitempty"`

		// UpgradeVotesRequired Yes votes required for consensus upgrade
		UpgradeVotesRequired *int `json:"upgrade-votes-required,omitempty"`

		// UpgradeYesVotes Yes votes cast for consensus upgrade
		UpgradeYesVotes *int `json:"upgrade-yes-votes,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
	JSON503 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r WaitForBlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WaitForBlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TealDisassembleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Result disassembled Teal code
		Result string `json:"result"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TealDisassembleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TealDisassembleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TealDryrunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Error string `json:"error"`

		// ProtocolVersion Protocol version is the protocol version Dryrun was operated under.
		ProtocolVersion string            `json:"protocol-version"`
		Txns            []DryrunTxnResult `json:"txns"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TealDryrunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TealDryrunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TxId encoding of the transaction hash.
		TxId string `json:"txId"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
	JSON503 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RawTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RawTransactionAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RawTransactionAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RawTransactionAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransactionParamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ConsensusVersion ConsensusVersion indicates the consensus protocol version
		// as of LastRound.
		ConsensusVersion string `json:"consensus-version"`

		// Fee Fee is the suggested transaction fee
		// Fee is in units of micro-Algos per byte.
		// Fee may fall to zero but transactions must still have a fee of
		// at least MinTxnFee for the current network protocol.
		Fee int `json:"fee"`

		// GenesisHash GenesisHash is the hash of the genesis block.
		GenesisHash []byte `json:"genesis-hash"`

		// GenesisId GenesisID is an ID listed in the genesis block.
		GenesisId string `json:"genesis-id"`

		// LastRound LastRound indicates the last round seen
		LastRound int `json:"last-round"`

		// MinFee The minimum transaction fee (not per byte) required for the
		// txn to validate for the current network protocol.
		MinFee int `json:"min-fee"`
	}
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
	JSON503 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TransactionParamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransactionParamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPendingTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TopTransactions An array of signed transaction objects.
		TopTransactions []map[string]interface{} `json:"top-transactions"`

		// TotalTransactions Total number of transactions in the pool.
		TotalTransactions int `json:"total-transactions"`
	}
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
	JSON503 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPendingTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PendingTransactionInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PendingTransactionResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PendingTransactionInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PendingTransactionInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SimulateTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// EvalOverrides The set of parameters and limits override during simulation. If this set of parameters is present, then evaluation parameters may differ from standard evaluation in certain ways.
		EvalOverrides *SimulationEvalOverrides `json:"eval-overrides,omitempty"`

		// ExecTraceConfig An object that configures simulation execution trace.
		ExecTraceConfig *SimulateTraceConfig `json:"exec-trace-config,omitempty"`

		// InitialStates Initial states of resources that were accessed during simulation.
		InitialStates *SimulateInitialStates `json:"initial-states,omitempty"`

		// LastRound The round immediately preceding this simulation. State changes through this round were used to run this simulation.
		LastRound int `json:"last-round"`

		// TxnGroups A result object for each transaction group that was simulated.
		TxnGroups []SimulateTransactionGroupResult `json:"txn-groups"`

		// Version The version of this response object.
		Version int `json:"version"`
	}
	JSON400 *ErrorResponse
	JSON401 *ErrorResponse
	JSON500 *ErrorResponse
	JSON503 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SimulateTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SimulateTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Version
}

// Status returns HTTPResponse.Status
func (r GetVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetDebugSettingsProfWithResponse request returning *GetDebugSettingsProfResponse
func (c *ClientWithResponses) GetDebugSettingsProfWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDebugSettingsProfResponse, error) {
	rsp, err := c.GetDebugSettingsProf(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDebugSettingsProfResponse(rsp)
}

// PutDebugSettingsProfWithResponse request returning *PutDebugSettingsProfResponse
func (c *ClientWithResponses) PutDebugSettingsProfWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PutDebugSettingsProfResponse, error) {
	rsp, err := c.PutDebugSettingsProf(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDebugSettingsProfResponse(rsp)
}

// GetGenesisWithResponse request returning *GetGenesisResponse
func (c *ClientWithResponses) GetGenesisWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGenesisResponse, error) {
	rsp, err := c.GetGenesis(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGenesisResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// MetricsWithResponse request returning *MetricsResponse
func (c *ClientWithResponses) MetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetricsResponse, error) {
	rsp, err := c.Metrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetricsResponse(rsp)
}

// GetReadyWithResponse request returning *GetReadyResponse
func (c *ClientWithResponses) GetReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadyResponse, error) {
	rsp, err := c.GetReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReadyResponse(rsp)
}

// SwaggerJSONWithResponse request returning *SwaggerJSONResponse
func (c *ClientWithResponses) SwaggerJSONWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SwaggerJSONResponse, error) {
	rsp, err := c.SwaggerJSON(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSwaggerJSONResponse(rsp)
}

// AccountInformationWithResponse request returning *AccountInformationResponse
func (c *ClientWithResponses) AccountInformationWithResponse(ctx context.Context, address string, params *AccountInformationParams, reqEditors ...RequestEditorFn) (*AccountInformationResponse, error) {
	rsp, err := c.AccountInformation(ctx, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountInformationResponse(rsp)
}

// AccountApplicationInformationWithResponse request returning *AccountApplicationInformationResponse
func (c *ClientWithResponses) AccountApplicationInformationWithResponse(ctx context.Context, address string, applicationId int, params *AccountApplicationInformationParams, reqEditors ...RequestEditorFn) (*AccountApplicationInformationResponse, error) {
	rsp, err := c.AccountApplicationInformation(ctx, address, applicationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountApplicationInformationResponse(rsp)
}

// AccountAssetsInformationWithResponse request returning *AccountAssetsInformationResponse
func (c *ClientWithResponses) AccountAssetsInformationWithResponse(ctx context.Context, address string, params *AccountAssetsInformationParams, reqEditors ...RequestEditorFn) (*AccountAssetsInformationResponse, error) {
	rsp, err := c.AccountAssetsInformation(ctx, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountAssetsInformationResponse(rsp)
}

// AccountAssetInformationWithResponse request returning *AccountAssetInformationResponse
func (c *ClientWithResponses) AccountAssetInformationWithResponse(ctx context.Context, address string, assetId int, params *AccountAssetInformationParams, reqEditors ...RequestEditorFn) (*AccountAssetInformationResponse, error) {
	rsp, err := c.AccountAssetInformation(ctx, address, assetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountAssetInformationResponse(rsp)
}

// GetPendingTransactionsByAddressWithResponse request returning *GetPendingTransactionsByAddressResponse
func (c *ClientWithResponses) GetPendingTransactionsByAddressWithResponse(ctx context.Context, address string, params *GetPendingTransactionsByAddressParams, reqEditors ...RequestEditorFn) (*GetPendingTransactionsByAddressResponse, error) {
	rsp, err := c.GetPendingTransactionsByAddress(ctx, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingTransactionsByAddressResponse(rsp)
}

// GetApplicationByIDWithResponse request returning *GetApplicationByIDResponse
func (c *ClientWithResponses) GetApplicationByIDWithResponse(ctx context.Context, applicationId int, reqEditors ...RequestEditorFn) (*GetApplicationByIDResponse, error) {
	rsp, err := c.GetApplicationByID(ctx, applicationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationByIDResponse(rsp)
}

// GetApplicationBoxByNameWithResponse request returning *GetApplicationBoxByNameResponse
func (c *ClientWithResponses) GetApplicationBoxByNameWithResponse(ctx context.Context, applicationId int, params *GetApplicationBoxByNameParams, reqEditors ...RequestEditorFn) (*GetApplicationBoxByNameResponse, error) {
	rsp, err := c.GetApplicationBoxByName(ctx, applicationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationBoxByNameResponse(rsp)
}

// GetApplicationBoxesWithResponse request returning *GetApplicationBoxesResponse
func (c *ClientWithResponses) GetApplicationBoxesWithResponse(ctx context.Context, applicationId int, params *GetApplicationBoxesParams, reqEditors ...RequestEditorFn) (*GetApplicationBoxesResponse, error) {
	rsp, err := c.GetApplicationBoxes(ctx, applicationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationBoxesResponse(rsp)
}

// GetAssetByIDWithResponse request returning *GetAssetByIDResponse
func (c *ClientWithResponses) GetAssetByIDWithResponse(ctx context.Context, assetId int, reqEditors ...RequestEditorFn) (*GetAssetByIDResponse, error) {
	rsp, err := c.GetAssetByID(ctx, assetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetByIDResponse(rsp)
}

// GetBlockWithResponse request returning *GetBlockResponse
func (c *ClientWithResponses) GetBlockWithResponse(ctx context.Context, round int, params *GetBlockParams, reqEditors ...RequestEditorFn) (*GetBlockResponse, error) {
	rsp, err := c.GetBlock(ctx, round, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockResponse(rsp)
}

// GetBlockHashWithResponse request returning *GetBlockHashResponse
func (c *ClientWithResponses) GetBlockHashWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*GetBlockHashResponse, error) {
	rsp, err := c.GetBlockHash(ctx, round, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockHashResponse(rsp)
}

// GetLightBlockHeaderProofWithResponse request returning *GetLightBlockHeaderProofResponse
func (c *ClientWithResponses) GetLightBlockHeaderProofWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*GetLightBlockHeaderProofResponse, error) {
	rsp, err := c.GetLightBlockHeaderProof(ctx, round, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLightBlockHeaderProofResponse(rsp)
}

// GetBlockLogsWithResponse request returning *GetBlockLogsResponse
func (c *ClientWithResponses) GetBlockLogsWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*GetBlockLogsResponse, error) {
	rsp, err := c.GetBlockLogs(ctx, round, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockLogsResponse(rsp)
}

// GetTransactionProofWithResponse request returning *GetTransactionProofResponse
func (c *ClientWithResponses) GetTransactionProofWithResponse(ctx context.Context, round int, txid string, params *GetTransactionProofParams, reqEditors ...RequestEditorFn) (*GetTransactionProofResponse, error) {
	rsp, err := c.GetTransactionProof(ctx, round, txid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionProofResponse(rsp)
}

// GetBlockTxidsWithResponse request returning *GetBlockTxidsResponse
func (c *ClientWithResponses) GetBlockTxidsWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*GetBlockTxidsResponse, error) {
	rsp, err := c.GetBlockTxids(ctx, round, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockTxidsResponse(rsp)
}

// AbortCatchupWithResponse request returning *AbortCatchupResponse
func (c *ClientWithResponses) AbortCatchupWithResponse(ctx context.Context, catchpoint string, reqEditors ...RequestEditorFn) (*AbortCatchupResponse, error) {
	rsp, err := c.AbortCatchup(ctx, catchpoint, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortCatchupResponse(rsp)
}

// StartCatchupWithResponse request returning *StartCatchupResponse
func (c *ClientWithResponses) StartCatchupWithResponse(ctx context.Context, catchpoint string, params *StartCatchupParams, reqEditors ...RequestEditorFn) (*StartCatchupResponse, error) {
	rsp, err := c.StartCatchup(ctx, catchpoint, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartCatchupResponse(rsp)
}

// GetLedgerStateDeltaForTransactionGroupWithResponse request returning *GetLedgerStateDeltaForTransactionGroupResponse
func (c *ClientWithResponses) GetLedgerStateDeltaForTransactionGroupWithResponse(ctx context.Context, id string, params *GetLedgerStateDeltaForTransactionGroupParams, reqEditors ...RequestEditorFn) (*GetLedgerStateDeltaForTransactionGroupResponse, error) {
	rsp, err := c.GetLedgerStateDeltaForTransactionGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLedgerStateDeltaForTransactionGroupResponse(rsp)
}

// GetLedgerStateDeltaWithResponse request returning *GetLedgerStateDeltaResponse
func (c *ClientWithResponses) GetLedgerStateDeltaWithResponse(ctx context.Context, round int, params *GetLedgerStateDeltaParams, reqEditors ...RequestEditorFn) (*GetLedgerStateDeltaResponse, error) {
	rsp, err := c.GetLedgerStateDelta(ctx, round, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLedgerStateDeltaResponse(rsp)
}

// GetTransactionGroupLedgerStateDeltasForRoundWithResponse request returning *GetTransactionGroupLedgerStateDeltasForRoundResponse
func (c *ClientWithResponses) GetTransactionGroupLedgerStateDeltasForRoundWithResponse(ctx context.Context, round int, params *GetTransactionGroupLedgerStateDeltasForRoundParams, reqEditors ...RequestEditorFn) (*GetTransactionGroupLedgerStateDeltasForRoundResponse, error) {
	rsp, err := c.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionGroupLedgerStateDeltasForRoundResponse(rsp)
}

// GetBlockTimeStampOffsetWithResponse request returning *GetBlockTimeStampOffsetResponse
func (c *ClientWithResponses) GetBlockTimeStampOffsetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBlockTimeStampOffsetResponse, error) {
	rsp, err := c.GetBlockTimeStampOffset(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlockTimeStampOffsetResponse(rsp)
}

// SetBlockTimeStampOffsetWithResponse request returning *SetBlockTimeStampOffsetResponse
func (c *ClientWithResponses) SetBlockTimeStampOffsetWithResponse(ctx context.Context, offset int, reqEditors ...RequestEditorFn) (*SetBlockTimeStampOffsetResponse, error) {
	rsp, err := c.SetBlockTimeStampOffset(ctx, offset, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBlockTimeStampOffsetResponse(rsp)
}

// ExperimentalCheckWithResponse request returning *ExperimentalCheckResponse
func (c *ClientWithResponses) ExperimentalCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExperimentalCheckResponse, error) {
	rsp, err := c.ExperimentalCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExperimentalCheckResponse(rsp)
}

// GetSupplyWithResponse request returning *GetSupplyResponse
func (c *ClientWithResponses) GetSupplyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSupplyResponse, error) {
	rsp, err := c.GetSupply(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSupplyResponse(rsp)
}

// UnsetSyncRoundWithResponse request returning *UnsetSyncRoundResponse
func (c *ClientWithResponses) UnsetSyncRoundWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UnsetSyncRoundResponse, error) {
	rsp, err := c.UnsetSyncRound(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnsetSyncRoundResponse(rsp)
}

// GetSyncRoundWithResponse request returning *GetSyncRoundResponse
func (c *ClientWithResponses) GetSyncRoundWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSyncRoundResponse, error) {
	rsp, err := c.GetSyncRound(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyncRoundResponse(rsp)
}

// SetSyncRoundWithResponse request returning *SetSyncRoundResponse
func (c *ClientWithResponses) SetSyncRoundWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*SetSyncRoundResponse, error) {
	rsp, err := c.SetSyncRound(ctx, round, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSyncRoundResponse(rsp)
}

// GetParticipationKeysWithResponse request returning *GetParticipationKeysResponse
func (c *ClientWithResponses) GetParticipationKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetParticipationKeysResponse, error) {
	rsp, err := c.GetParticipationKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetParticipationKeysResponse(rsp)
}

// AddParticipationKeyWithBodyWithResponse request with arbitrary body returning *AddParticipationKeyResponse
func (c *ClientWithResponses) AddParticipationKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddParticipationKeyResponse, error) {
	rsp, err := c.AddParticipationKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddParticipationKeyResponse(rsp)
}

// GenerateParticipationKeysWithResponse request returning *GenerateParticipationKeysResponse
func (c *ClientWithResponses) GenerateParticipationKeysWithResponse(ctx context.Context, address string, params *GenerateParticipationKeysParams, reqEditors ...RequestEditorFn) (*GenerateParticipationKeysResponse, error) {
	rsp, err := c.GenerateParticipationKeys(ctx, address, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateParticipationKeysResponse(rsp)
}

// DeleteParticipationKeyByIDWithResponse request returning *DeleteParticipationKeyByIDResponse
func (c *ClientWithResponses) DeleteParticipationKeyByIDWithResponse(ctx context.Context, participationId string, reqEditors ...RequestEditorFn) (*DeleteParticipationKeyByIDResponse, error) {
	rsp, err := c.DeleteParticipationKeyByID(ctx, participationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteParticipationKeyByIDResponse(rsp)
}

// GetParticipationKeyByIDWithResponse request returning *GetParticipationKeyByIDResponse
func (c *ClientWithResponses) GetParticipationKeyByIDWithResponse(ctx context.Context, participationId string, reqEditors ...RequestEditorFn) (*GetParticipationKeyByIDResponse, error) {
	rsp, err := c.GetParticipationKeyByID(ctx, participationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetParticipationKeyByIDResponse(rsp)
}

// AppendKeysWithBodyWithResponse request with arbitrary body returning *AppendKeysResponse
func (c *ClientWithResponses) AppendKeysWithBodyWithResponse(ctx context.Context, participationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppendKeysResponse, error) {
	rsp, err := c.AppendKeysWithBody(ctx, participationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppendKeysResponse(rsp)
}

// ShutdownNodeWithResponse request returning *ShutdownNodeResponse
func (c *ClientWithResponses) ShutdownNodeWithResponse(ctx context.Context, params *ShutdownNodeParams, reqEditors ...RequestEditorFn) (*ShutdownNodeResponse, error) {
	rsp, err := c.ShutdownNode(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShutdownNodeResponse(rsp)
}

// GetStateProofWithResponse request returning *GetStateProofResponse
func (c *ClientWithResponses) GetStateProofWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*GetStateProofResponse, error) {
	rsp, err := c.GetStateProof(ctx, round, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStateProofResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// WaitForBlockWithResponse request returning *WaitForBlockResponse
func (c *ClientWithResponses) WaitForBlockWithResponse(ctx context.Context, round int, reqEditors ...RequestEditorFn) (*WaitForBlockResponse, error) {
	rsp, err := c.WaitForBlock(ctx, round, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWaitForBlockResponse(rsp)
}

// TealDisassembleWithBodyWithResponse request with arbitrary body returning *TealDisassembleResponse
func (c *ClientWithResponses) TealDisassembleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TealDisassembleResponse, error) {
	rsp, err := c.TealDisassembleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTealDisassembleResponse(rsp)
}

// TealDryrunWithBodyWithResponse request with arbitrary body returning *TealDryrunResponse
func (c *ClientWithResponses) TealDryrunWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TealDryrunResponse, error) {
	rsp, err := c.TealDryrunWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTealDryrunResponse(rsp)
}

func (c *ClientWithResponses) TealDryrunWithResponse(ctx context.Context, body TealDryrunJSONRequestBody, reqEditors ...RequestEditorFn) (*TealDryrunResponse, error) {
	rsp, err := c.TealDryrun(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTealDryrunResponse(rsp)
}

// RawTransactionWithBodyWithResponse request with arbitrary body returning *RawTransactionResponse
func (c *ClientWithResponses) RawTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RawTransactionResponse, error) {
	rsp, err := c.RawTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawTransactionResponse(rsp)
}

// RawTransactionAsyncWithBodyWithResponse request with arbitrary body returning *RawTransactionAsyncResponse
func (c *ClientWithResponses) RawTransactionAsyncWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RawTransactionAsyncResponse, error) {
	rsp, err := c.RawTransactionAsyncWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRawTransactionAsyncResponse(rsp)
}

// TransactionParamsWithResponse request returning *TransactionParamsResponse
func (c *ClientWithResponses) TransactionParamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TransactionParamsResponse, error) {
	rsp, err := c.TransactionParams(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransactionParamsResponse(rsp)
}

// GetPendingTransactionsWithResponse request returning *GetPendingTransactionsResponse
func (c *ClientWithResponses) GetPendingTransactionsWithResponse(ctx context.Context, params *GetPendingTransactionsParams, reqEditors ...RequestEditorFn) (*GetPendingTransactionsResponse, error) {
	rsp, err := c.GetPendingTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingTransactionsResponse(rsp)
}

// PendingTransactionInformationWithResponse request returning *PendingTransactionInformationResponse
func (c *ClientWithResponses) PendingTransactionInformationWithResponse(ctx context.Context, txid string, params *PendingTransactionInformationParams, reqEditors ...RequestEditorFn) (*PendingTransactionInformationResponse, error) {
	rsp, err := c.PendingTransactionInformation(ctx, txid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePendingTransactionInformationResponse(rsp)
}

// SimulateTransactionWithBodyWithResponse request with arbitrary body returning *SimulateTransactionResponse
func (c *ClientWithResponses) SimulateTransactionWithBodyWithResponse(ctx context.Context, params *SimulateTransactionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SimulateTransactionResponse, error) {
	rsp, err := c.SimulateTransactionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSimulateTransactionResponse(rsp)
}

func (c *ClientWithResponses) SimulateTransactionWithResponse(ctx context.Context, params *SimulateTransactionParams, body SimulateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*SimulateTransactionResponse, error) {
	rsp, err := c.SimulateTransaction(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSimulateTransactionResponse(rsp)
}

// GetVersionWithResponse request returning *GetVersionResponse
func (c *ClientWithResponses) GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error) {
	rsp, err := c.GetVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionResponse(rsp)
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDebugSettingsProfResponse parses an HTTP response from a GetDebugSettingsProfWithResponse call
func ParseGetDebugSettingsProfResponse(rsp *http.Response) (*GetDebugSettingsProfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDebugSettingsProfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DebugSettingsProf
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutDebugSettingsProfResponse parses an HTTP response from a PutDebugSettingsProfWithResponse call
func ParsePutDebugSettingsProfResponse(rsp *http.Response) (*PutDebugSettingsProfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutDebugSettingsProfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DebugSettingsProf
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGenesisResponse parses an HTTP response from a GetGenesisWithResponse call
func ParseGetGenesisResponse(rsp *http.Response) (*GetGenesisResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGenesisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMetricsResponse parses an HTTP response from a MetricsWithResponse call
func ParseMetricsResponse(rsp *http.Response) (*MetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReadyResponse parses an HTTP response from a GetReadyWithResponse call
func ParseGetReadyResponse(rsp *http.Response) (*GetReadyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSwaggerJSONResponse parses an HTTP response from a SwaggerJSONWithResponse call
func ParseSwaggerJSONResponse(rsp *http.Response) (*SwaggerJSONResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SwaggerJSONResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAccountInformationResponse parses an HTTP response from a AccountInformationWithResponse call
func ParseAccountInformationResponse(rsp *http.Response) (*AccountInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 400:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseAccountApplicationInformationResponse parses an HTTP response from a AccountApplicationInformationWithResponse call
func ParseAccountApplicationInformationResponse(rsp *http.Response) (*AccountApplicationInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountApplicationInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AppLocalState Stores local state associated with an application.
			AppLocalState *ApplicationLocalState `json:"app-local-state,omitempty"`

			// CreatedApp Stores the global information associated with an application.
			CreatedApp *ApplicationParams `json:"created-app,omitempty"`

			// Round The round for which this information is relevant.
			Round int `json:"round"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 400:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseAccountAssetsInformationResponse parses an HTTP response from a AccountAssetsInformationWithResponse call
func ParseAccountAssetsInformationResponse(rsp *http.Response) (*AccountAssetsInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountAssetsInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssetHoldings *[]AccountAssetHolding `json:"asset-holdings,omitempty"`

			// NextToken Used for pagination, when making another request provide this token with the next parameter.
			NextToken *string `json:"next-token,omitempty"`

			// Round The round for which this information is relevant.
			Round int `json:"round"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAccountAssetInformationResponse parses an HTTP response from a AccountAssetInformationWithResponse call
func ParseAccountAssetInformationResponse(rsp *http.Response) (*AccountAssetInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountAssetInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssetHolding Describes an asset held by an account.
			//
			// Definition:
			// data/basics/userBalance.go : AssetHolding
			AssetHolding *AssetHolding `json:"asset-holding,omitempty"`

			// CreatedAsset AssetParams specifies the parameters for an asset.
			//
			// \[apar\] when part of an AssetConfig transaction.
			//
			// Definition:
			// data/transactions/asset.go : AssetParams
			CreatedAsset *AssetParams `json:"created-asset,omitempty"`

			// Round The round for which this information is relevant.
			Round int `json:"round"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 400:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetPendingTransactionsByAddressResponse parses an HTTP response from a GetPendingTransactionsByAddressWithResponse call
func ParseGetPendingTransactionsByAddressResponse(rsp *http.Response) (*GetPendingTransactionsByAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingTransactionsByAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TopTransactions An array of signed transaction objects.
			TopTransactions []map[string]interface{} `json:"top-transactions"`

			// TotalTransactions Total number of transactions in the pool.
			TotalTransactions int `json:"total-transactions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 400:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 500:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 503:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetApplicationByIDResponse parses an HTTP response from a GetApplicationByIDWithResponse call
func ParseGetApplicationByIDResponse(rsp *http.Response) (*GetApplicationByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Application
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApplicationBoxByNameResponse parses an HTTP response from a GetApplicationBoxByNameWithResponse call
func ParseGetApplicationBoxByNameResponse(rsp *http.Response) (*GetApplicationBoxByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationBoxByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Box
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApplicationBoxesResponse parses an HTTP response from a GetApplicationBoxesWithResponse call
func ParseGetApplicationBoxesResponse(rsp *http.Response) (*GetApplicationBoxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationBoxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Boxes []BoxDescriptor `json:"boxes"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAssetByIDResponse parses an HTTP response from a GetAssetByIDWithResponse call
func ParseGetAssetByIDResponse(rsp *http.Response) (*GetAssetByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Asset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBlockResponse parses an HTTP response from a GetBlockWithResponse call
func ParseGetBlockResponse(rsp *http.Response) (*GetBlockResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Block Block header data.
			Block map[string]interface{} `json:"block"`

			// Cert Optional certificate object. This is only included when the format is set to message pack.
			Cert *map[string]interface{} `json:"cert,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 400:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 404:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetBlockHashResponse parses an HTTP response from a GetBlockHashWithResponse call
func ParseGetBlockHashResponse(rsp *http.Response) (*GetBlockHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BlockHash Block header hash.
			BlockHash string `json:"blockHash"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLightBlockHeaderProofResponse parses an HTTP response from a GetLightBlockHeaderProofWithResponse call
func ParseGetLightBlockHeaderProofResponse(rsp *http.Response) (*GetLightBlockHeaderProofResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLightBlockHeaderProofResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LightBlockHeaderProof
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetBlockLogsResponse parses an HTTP response from a GetBlockLogsWithResponse call
func ParseGetBlockLogsResponse(rsp *http.Response) (*GetBlockLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Logs []AppCallLogs `json:"logs"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTransactionProofResponse parses an HTTP response from a GetTransactionProofWithResponse call
func ParseGetTransactionProofResponse(rsp *http.Response) (*GetTransactionProofResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionProofResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Hashtype The type of hash function used to create the proof, must be one of:
			// * sha512_256
			// * sha256
			Hashtype GetTransactionProof200Hashtype `json:"hashtype"`

			// Idx Index of the transaction in the block's payset.
			Idx int `json:"idx"`

			// Proof Proof of transaction membership.
			Proof []byte `json:"proof"`

			// Stibhash Hash of SignedTxnInBlock for verifying proof.
			Stibhash []byte `json:"stibhash"`

			// Treedepth Represents the depth of the tree that is being proven, i.e. the number of edges from a leaf to the root.
			Treedepth int `json:"treedepth"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBlockTxidsResponse parses an HTTP response from a GetBlockTxidsWithResponse call
func ParseGetBlockTxidsResponse(rsp *http.Response) (*GetBlockTxidsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockTxidsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BlockTxids Block transaction IDs.
			BlockTxids []string `json:"blockTxids"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAbortCatchupResponse parses an HTTP response from a AbortCatchupWithResponse call
func ParseAbortCatchupResponse(rsp *http.Response) (*AbortCatchupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AbortCatchupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CatchupMessage Catchup abort response string
			CatchupMessage string `json:"catchup-message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartCatchupResponse parses an HTTP response from a StartCatchupWithResponse call
func ParseStartCatchupResponse(rsp *http.Response) (*StartCatchupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartCatchupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CatchupMessage Catchup start response string
			CatchupMessage string `json:"catchup-message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// CatchupMessage Catchup start response string
			CatchupMessage string `json:"catchup-message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLedgerStateDeltaForTransactionGroupResponse parses an HTTP response from a GetLedgerStateDeltaForTransactionGroupWithResponse call
func ParseGetLedgerStateDeltaForTransactionGroupResponse(rsp *http.Response) (*GetLedgerStateDeltaForTransactionGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLedgerStateDeltaForTransactionGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LedgerStateDelta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 404:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 408:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 500:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 501:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetLedgerStateDeltaResponse parses an HTTP response from a GetLedgerStateDeltaWithResponse call
func ParseGetLedgerStateDeltaResponse(rsp *http.Response) (*GetLedgerStateDeltaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLedgerStateDeltaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LedgerStateDelta
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 404:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 408:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 500:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 503:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetTransactionGroupLedgerStateDeltasForRoundResponse parses an HTTP response from a GetTransactionGroupLedgerStateDeltasForRoundWithResponse call
func ParseGetTransactionGroupLedgerStateDeltasForRoundResponse(rsp *http.Response) (*GetTransactionGroupLedgerStateDeltasForRoundResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionGroupLedgerStateDeltasForRoundResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Deltas []LedgerStateDeltaForTransactionGroup `json:"Deltas"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 404:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 408:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 500:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 501:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetBlockTimeStampOffsetResponse parses an HTTP response from a GetBlockTimeStampOffsetWithResponse call
func ParseGetBlockTimeStampOffsetResponse(rsp *http.Response) (*GetBlockTimeStampOffsetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlockTimeStampOffsetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Offset Timestamp offset in seconds.
			Offset int `json:"offset"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSetBlockTimeStampOffsetResponse parses an HTTP response from a SetBlockTimeStampOffsetWithResponse call
func ParseSetBlockTimeStampOffsetResponse(rsp *http.Response) (*SetBlockTimeStampOffsetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBlockTimeStampOffsetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExperimentalCheckResponse parses an HTTP response from a ExperimentalCheckWithResponse call
func ParseExperimentalCheckResponse(rsp *http.Response) (*ExperimentalCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExperimentalCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSupplyResponse parses an HTTP response from a GetSupplyWithResponse call
func ParseGetSupplyResponse(rsp *http.Response) (*GetSupplyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupplyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CurrentRound Round
			CurrentRound int `json:"current_round"`

			// OnlineMoney OnlineMoney
			OnlineMoney int `json:"online-money"`

			// TotalMoney TotalMoney
			TotalMoney int `json:"total-money"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUnsetSyncRoundResponse parses an HTTP response from a UnsetSyncRoundWithResponse call
func ParseUnsetSyncRoundResponse(rsp *http.Response) (*UnsetSyncRoundResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnsetSyncRoundResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetSyncRoundResponse parses an HTTP response from a GetSyncRoundWithResponse call
func ParseGetSyncRoundResponse(rsp *http.Response) (*GetSyncRoundResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyncRoundResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Round The minimum sync round for the ledger.
			Round int `json:"round"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSetSyncRoundResponse parses an HTTP response from a SetSyncRoundWithResponse call
func ParseSetSyncRoundResponse(rsp *http.Response) (*SetSyncRoundResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSyncRoundResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetParticipationKeysResponse parses an HTTP response from a GetParticipationKeysWithResponse call
func ParseGetParticipationKeysResponse(rsp *http.Response) (*GetParticipationKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetParticipationKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ParticipationKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddParticipationKeyResponse parses an HTTP response from a AddParticipationKeyWithResponse call
func ParseAddParticipationKeyResponse(rsp *http.Response) (*AddParticipationKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddParticipationKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// PartId encoding of the participation ID.
			PartId string `json:"partId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGenerateParticipationKeysResponse parses an HTTP response from a GenerateParticipationKeysWithResponse call
func ParseGenerateParticipationKeysResponse(rsp *http.Response) (*GenerateParticipationKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateParticipationKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteParticipationKeyByIDResponse parses an HTTP response from a DeleteParticipationKeyByIDWithResponse call
func ParseDeleteParticipationKeyByIDResponse(rsp *http.Response) (*DeleteParticipationKeyByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteParticipationKeyByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetParticipationKeyByIDResponse parses an HTTP response from a GetParticipationKeyByIDWithResponse call
func ParseGetParticipationKeyByIDResponse(rsp *http.Response) (*GetParticipationKeyByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetParticipationKeyByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ParticipationKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAppendKeysResponse parses an HTTP response from a AppendKeysWithResponse call
func ParseAppendKeysResponse(rsp *http.Response) (*AppendKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppendKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ParticipationKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShutdownNodeResponse parses an HTTP response from a ShutdownNodeWithResponse call
func ParseShutdownNodeResponse(rsp *http.Response) (*ShutdownNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShutdownNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStateProofResponse parses an HTTP response from a GetStateProofWithResponse call
func ParseGetStateProofResponse(rsp *http.Response) (*GetStateProofResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStateProofResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StateProof
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Catchpoint The current catchpoint that is being caught up to
			Catchpoint *string `json:"catchpoint,omitempty"`

			// CatchpointAcquiredBlocks The number of blocks that have already been obtained by the node as part of the catchup
			CatchpointAcquiredBlocks *int `json:"catchpoint-acquired-blocks,omitempty"`

			// CatchpointProcessedAccounts The number of accounts from the current catchpoint that have been processed so far as part of the catchup
			CatchpointProcessedAccounts *int `json:"catchpoint-processed-accounts,omitempty"`

			// CatchpointProcessedKvs The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup
			CatchpointProcessedKvs *int `json:"catchpoint-processed-kvs,omitempty"`

			// CatchpointTotalAccounts The total number of accounts included in the current catchpoint
			CatchpointTotalAccounts *int `json:"catchpoint-total-accounts,omitempty"`

			// CatchpointTotalBlocks The total number of blocks that are required to complete the current catchpoint catchup
			CatchpointTotalBlocks *int `json:"catchpoint-total-blocks,omitempty"`

			// CatchpointTotalKvs The total number of key-values (KVs) included in the current catchpoint
			CatchpointTotalKvs *int `json:"catchpoint-total-kvs,omitempty"`

			// CatchpointVerifiedAccounts The number of accounts from the current catchpoint that have been verified so far as part of the catchup
			CatchpointVerifiedAccounts *int `json:"catchpoint-verified-accounts,omitempty"`

			// CatchpointVerifiedKvs The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup
			CatchpointVerifiedKvs *int `json:"catchpoint-verified-kvs,omitempty"`

			// CatchupTime CatchupTime in nanoseconds
			CatchupTime int `json:"catchup-time"`

			// LastCatchpoint The last catchpoint seen by the node
			LastCatchpoint *string `json:"last-catchpoint,omitempty"`

			// LastRound LastRound indicates the last round seen
			LastRound int `json:"last-round"`

			// LastVersion LastVersion indicates the last consensus version supported
			LastVersion string `json:"last-version"`

			// NextVersion NextVersion of consensus protocol to use
			NextVersion string `json:"next-version"`

			// NextVersionRound NextVersionRound is the round at which the next consensus version will apply
			NextVersionRound int `json:"next-version-round"`

			// NextVersionSupported NextVersionSupported indicates whether the next consensus version is supported by this node
			NextVersionSupported bool `json:"next-version-supported"`

			// StoppedAtUnsupportedRound StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress
			StoppedAtUnsupportedRound bool `json:"stopped-at-unsupported-round"`

			// TimeSinceLastRound TimeSinceLastRound in nanoseconds
			TimeSinceLastRound int `json:"time-since-last-round"`

			// UpgradeDelay Upgrade delay
			UpgradeDelay *int `json:"upgrade-delay,omitempty"`

			// UpgradeNextProtocolVoteBefore Next protocol round
			UpgradeNextProtocolVoteBefore *int `json:"upgrade-next-protocol-vote-before,omitempty"`

			// UpgradeNoVotes No votes cast for consensus upgrade
			UpgradeNoVotes *int `json:"upgrade-no-votes,omitempty"`

			// UpgradeNodeVote This node's upgrade vote
			UpgradeNodeVote *bool `json:"upgrade-node-vote,omitempty"`

			// UpgradeVoteRounds Total voting rounds for current upgrade
			UpgradeVoteRounds *int `json:"upgrade-vote-rounds,omitempty"`

			// UpgradeVotes Total votes cast for consensus upgrade
			UpgradeVotes *int `json:"upgrade-votes,omitempty"`

			// UpgradeVotesRequired Yes votes required for consensus upgrade
			UpgradeVotesRequired *int `json:"upgrade-votes-required,omitempty"`

			// UpgradeYesVotes Yes votes cast for consensus upgrade
			UpgradeYesVotes *int `json:"upgrade-yes-votes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWaitForBlockResponse parses an HTTP response from a WaitForBlockWithResponse call
func ParseWaitForBlockResponse(rsp *http.Response) (*WaitForBlockResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WaitForBlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Catchpoint The current catchpoint that is being caught up to
			Catchpoint *string `json:"catchpoint,omitempty"`

			// CatchpointAcquiredBlocks The number of blocks that have already been obtained by the node as part of the catchup
			CatchpointAcquiredBlocks *int `json:"catchpoint-acquired-blocks,omitempty"`

			// CatchpointProcessedAccounts The number of accounts from the current catchpoint that have been processed so far as part of the catchup
			CatchpointProcessedAccounts *int `json:"catchpoint-processed-accounts,omitempty"`

			// CatchpointProcessedKvs The number of key-values (KVs) from the current catchpoint that have been processed so far as part of the catchup
			CatchpointProcessedKvs *int `json:"catchpoint-processed-kvs,omitempty"`

			// CatchpointTotalAccounts The total number of accounts included in the current catchpoint
			CatchpointTotalAccounts *int `json:"catchpoint-total-accounts,omitempty"`

			// CatchpointTotalBlocks The total number of blocks that are required to complete the current catchpoint catchup
			CatchpointTotalBlocks *int `json:"catchpoint-total-blocks,omitempty"`

			// CatchpointTotalKvs The total number of key-values (KVs) included in the current catchpoint
			CatchpointTotalKvs *int `json:"catchpoint-total-kvs,omitempty"`

			// CatchpointVerifiedAccounts The number of accounts from the current catchpoint that have been verified so far as part of the catchup
			CatchpointVerifiedAccounts *int `json:"catchpoint-verified-accounts,omitempty"`

			// CatchpointVerifiedKvs The number of key-values (KVs) from the current catchpoint that have been verified so far as part of the catchup
			CatchpointVerifiedKvs *int `json:"catchpoint-verified-kvs,omitempty"`

			// CatchupTime CatchupTime in nanoseconds
			CatchupTime int `json:"catchup-time"`

			// LastCatchpoint The last catchpoint seen by the node
			LastCatchpoint *string `json:"last-catchpoint,omitempty"`

			// LastRound LastRound indicates the last round seen
			LastRound int `json:"last-round"`

			// LastVersion LastVersion indicates the last consensus version supported
			LastVersion string `json:"last-version"`

			// NextVersion NextVersion of consensus protocol to use
			NextVersion string `json:"next-version"`

			// NextVersionRound NextVersionRound is the round at which the next consensus version will apply
			NextVersionRound int `json:"next-version-round"`

			// NextVersionSupported NextVersionSupported indicates whether the next consensus version is supported by this node
			NextVersionSupported bool `json:"next-version-supported"`

			// StoppedAtUnsupportedRound StoppedAtUnsupportedRound indicates that the node does not support the new rounds and has stopped making progress
			StoppedAtUnsupportedRound bool `json:"stopped-at-unsupported-round"`

			// TimeSinceLastRound TimeSinceLastRound in nanoseconds
			TimeSinceLastRound int `json:"time-since-last-round"`

			// UpgradeDelay Upgrade delay
			UpgradeDelay *int `json:"upgrade-delay,omitempty"`

			// UpgradeNextProtocolVoteBefore Next protocol round
			UpgradeNextProtocolVoteBefore *int `json:"upgrade-next-protocol-vote-before,omitempty"`

			// UpgradeNoVotes No votes cast for consensus upgrade
			UpgradeNoVotes *int `json:"upgrade-no-votes,omitempty"`

			// UpgradeNodeVote This node's upgrade vote
			UpgradeNodeVote *bool `json:"upgrade-node-vote,omitempty"`

			// UpgradeVoteRounds Total voting rounds for current upgrade
			UpgradeVoteRounds *int `json:"upgrade-vote-rounds,omitempty"`

			// UpgradeVotes Total votes cast for consensus upgrade
			UpgradeVotes *int `json:"upgrade-votes,omitempty"`

			// UpgradeVotesRequired Yes votes required for consensus upgrade
			UpgradeVotesRequired *int `json:"upgrade-votes-required,omitempty"`

			// UpgradeYesVotes Yes votes cast for consensus upgrade
			UpgradeYesVotes *int `json:"upgrade-yes-votes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTealDisassembleResponse parses an HTTP response from a TealDisassembleWithResponse call
func ParseTealDisassembleResponse(rsp *http.Response) (*TealDisassembleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TealDisassembleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Result disassembled Teal code
			Result string `json:"result"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTealDryrunResponse parses an HTTP response from a TealDryrunWithResponse call
func ParseTealDryrunResponse(rsp *http.Response) (*TealDryrunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TealDryrunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Error string `json:"error"`

			// ProtocolVersion Protocol version is the protocol version Dryrun was operated under.
			ProtocolVersion string            `json:"protocol-version"`
			Txns            []DryrunTxnResult `json:"txns"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRawTransactionResponse parses an HTTP response from a RawTransactionWithResponse call
func ParseRawTransactionResponse(rsp *http.Response) (*RawTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TxId encoding of the transaction hash.
			TxId string `json:"txId"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseRawTransactionAsyncResponse parses an HTTP response from a RawTransactionAsyncWithResponse call
func ParseRawTransactionAsyncResponse(rsp *http.Response) (*RawTransactionAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RawTransactionAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTransactionParamsResponse parses an HTTP response from a TransactionParamsWithResponse call
func ParseTransactionParamsResponse(rsp *http.Response) (*TransactionParamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransactionParamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ConsensusVersion ConsensusVersion indicates the consensus protocol version
			// as of LastRound.
			ConsensusVersion string `json:"consensus-version"`

			// Fee Fee is the suggested transaction fee
			// Fee is in units of micro-Algos per byte.
			// Fee may fall to zero but transactions must still have a fee of
			// at least MinTxnFee for the current network protocol.
			Fee int `json:"fee"`

			// GenesisHash GenesisHash is the hash of the genesis block.
			GenesisHash []byte `json:"genesis-hash"`

			// GenesisId GenesisID is an ID listed in the genesis block.
			GenesisId string `json:"genesis-id"`

			// LastRound LastRound indicates the last round seen
			LastRound int `json:"last-round"`

			// MinFee The minimum transaction fee (not per byte) required for the
			// txn to validate for the current network protocol.
			MinFee int `json:"min-fee"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetPendingTransactionsResponse parses an HTTP response from a GetPendingTransactionsWithResponse call
func ParseGetPendingTransactionsResponse(rsp *http.Response) (*GetPendingTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TopTransactions An array of signed transaction objects.
			TopTransactions []map[string]interface{} `json:"top-transactions"`

			// TotalTransactions Total number of transactions in the pool.
			TotalTransactions int `json:"total-transactions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 500:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 503:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParsePendingTransactionInformationResponse parses an HTTP response from a PendingTransactionInformationWithResponse call
func ParsePendingTransactionInformationResponse(rsp *http.Response) (*PendingTransactionInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PendingTransactionInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PendingTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 400:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseSimulateTransactionResponse parses an HTTP response from a SimulateTransactionWithResponse call
func ParseSimulateTransactionResponse(rsp *http.Response) (*SimulateTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SimulateTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EvalOverrides The set of parameters and limits override during simulation. If this set of parameters is present, then evaluation parameters may differ from standard evaluation in certain ways.
			EvalOverrides *SimulationEvalOverrides `json:"eval-overrides,omitempty"`

			// ExecTraceConfig An object that configures simulation execution trace.
			ExecTraceConfig *SimulateTraceConfig `json:"exec-trace-config,omitempty"`

			// InitialStates Initial states of resources that were accessed during simulation.
			InitialStates *SimulateInitialStates `json:"initial-states,omitempty"`

			// LastRound The round immediately preceding this simulation. State changes through this round were used to run this simulation.
			LastRound int `json:"last-round"`

			// TxnGroups A result object for each transaction group that was simulated.
			TxnGroups []SimulateTransactionGroupResult `json:"txn-groups"`

			// Version The version of this response object.
			Version int `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 400:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 401:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 500:
	// Content-type (application/msgpack) unsupported

	case rsp.StatusCode == 503:
		// Content-type (application/msgpack) unsupported

	}

	return response, nil
}

// ParseGetVersionResponse parses an HTTP response from a GetVersionWithResponse call
func ParseGetVersionResponse(rsp *http.Response) (*GetVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
